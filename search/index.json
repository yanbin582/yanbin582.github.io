[{"content":"L1-009 N个数求和\n分数 20\n全屏浏览切换布局\n作者 陈越\n单位 浙江大学\n本题的要求很简单，就是求N个数字的和。麻烦的是，这些数字是以有理数分子/分母的形式给出的，你输出的和也必须是有理数的形式。\n输入格式：\n输入第一行给出一个正整数N（≤100）。随后一行按格式a1/b1 a2/b2 ...给出N个有理数。题目保证所有分子和分母都在长整型范围内。另外，负数的符号一定出现在分子前面。\n输出格式：\n输出上述数字和的最简形式 —— 即将结果写成整数部分 分数部分，其中分数部分写成分子/分母，要求分子小于分母，且它们没有公因子。如果结果的整数部分为0，则只输出分数部分。\n输入样例1：\n1 2 5 2/5 4/15 1/30 -2/60 8/3 输出样例1：\n1 3 1/3 输入样例2：\n1 2 2 4/3 2/3 输出样例2：\n1 2 输入样例3：\n1 2 3 1/3 -1/6 1/8 输出样例3：\n1 7/24 代码长度限制\n16 KB\n时间限制\n400 ms\n内存限制\n64 MB\n栈限制\n8192 KB\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 import java.io.*; import java.util.*; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int N = Integer.parseInt(br.readLine()); long fzTotal = 0; // 分子总数 long fmTotal = 1; // 分母的最小公倍数 String[] fractions = br.readLine().split(\u0026#34; \u0026#34;); for (String fraction : fractions) { String[] part = fraction.split(\u0026#34;/\u0026#34;); int fz = Integer.parseInt(part[0]); int fm = Integer.parseInt(part[1]); fmTotal = lcm(fmTotal, fm); // 计算所有分母的最小公倍数 } // 计算分子总数 for (String fraction : fractions) { String[] part = fraction.split(\u0026#34;/\u0026#34;); int fz = Integer.parseInt(part[0]); int fm = Integer.parseInt(part[1]); fzTotal += (fz * (fmTotal / fm)); // 统一转换成相同分母 } // 处理整数部分和分数部分 if (fzTotal == 0) { System.out.println(0); return; } long integerPart = fzTotal / fmTotal; // 整数部分 long remainderFz = Math.abs(fzTotal % fmTotal); // 剩余分子 long gcd = gcd(remainderFz, fmTotal); long fz = remainderFz / gcd; long fm = fmTotal / gcd; // 负数处理：整数部分不为 0，直接输出负号；否则，分数部分加负号 if (integerPart != 0) { if (fz == 0) { System.out.println(integerPart); // 只有整数部分 } else { System.out.println(integerPart + \u0026#34; \u0026#34; + fz + \u0026#34;/\u0026#34; + fm); } } else { // 只有分数部分 System.out.println((fzTotal \u0026lt; 0 ? \u0026#34;-\u0026#34; : \u0026#34;\u0026#34;) + fz + \u0026#34;/\u0026#34; + fm); } } // 计算最大公约数（GCD） public static long gcd(long a, long b) { a = Math.abs(a); while (b != 0) { long temp = b; b = a % b; a = temp; } return a; } // 计算最小公倍数（LCM） public static long lcm(long a, long b) { return a / gcd(a, b) * b; } } ","date":"2025-03-25T00:00:00Z","image":"https://yanbin582.github.io/p/%E5%A4%A9%E6%A2%AFl1-009-n%E4%B8%AA%E6%95%B0%E6%B1%82%E5%92%8C/image_hu7343995253115549451.png","permalink":"https://yanbin582.github.io/p/%E5%A4%A9%E6%A2%AFl1-009-n%E4%B8%AA%E6%95%B0%E6%B1%82%E5%92%8C/","title":"天梯L1-009 N个数求和"},{"content":"题目 博主解题思路： ​\t首先熟读题目后，发现要求的是，一段定长字符串中的abb形式的定长字串，如果定长字串的数量大于等于F的话，那么就可以列为一组答案，值得注意的是，字符串中可能存在至多一个字符与原始字符串不用，也就是说，可以在字串中更改一个字符，如果字符更改后的关联的定长字串的数量能大于等于F，那么也可以列入答案当中，那么思路就很明显了，首先，我们定义一个cnt数组，用来统计原字符串中的定长字串数量，再依次改变原字符串中的每一个字符，共有25种更改情况，每次改变字符，都会改变三个定长字串，如：\n值得注意的是，每次我们更改字符之前，我们将原来的关联的三个字串数量-1，这样子我们修改之后，得到新字串，加入到字串数量中，才能有效的判断是否出现了有效的答案字串，不然就会多加1，在改变字符之后，对应的三个新字串数量加一，判断是否有答案字串，如果有答案字串，那么就标记一下（开辟一个新的数组来记录答案字串），更新完之后，再减去字串数量-1，最后恢复现场，将原字符放回原位，并更新原字串数量，这样子就能达到至多只有一个字符改变的效果，最后统计答案字串数量，并输出答案子串\n说实话这个题目难度对目前的我来说难度还是比较大，但是搞懂本题之后，对我的思维拓展还是比较大，模拟题目或者需要重复执行类似操作的题目，可以开辟一个更新函数来重复操作，直观并且更为简洁\n答案： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import java.util.Scanner; public class Main{ private static final int N = 20010; // N 设为静态常量 private static final int M = 26; private static Integer n; private static Integer m; private static char[] s; private static int[][] cnt=new int[M][M]; private static boolean[][] ans=new boolean[M][M]; public static void main(String agrs[]){ Scanner sc=new Scanner(System.in); n =sc.nextInt(); m=sc.nextInt(); sc.nextLine(); String S=sc.nextLine(); s=S.toCharArray(); //先将字符转换为数字 for (int i = 0; i \u0026lt; s.length; i++) s[i]-=\u0026#39;a\u0026#39;; //先统计原字符串中的哞叫可能 update(0,n-1,1); for (int i = 0; i \u0026lt; n; i++) { char t=s[i]; update(i-2,i+2,-1); for (int j = 0; j \u0026lt; 26; j++) { if (j!=t){ s[i]= (char) j; update(i-2,i+2,1); update(i-2,i+2,-1); } } s[i]=t; update(i-2,i+2,1); } int res=0; for (int i = 0; i \u0026lt; 26; i++) { for (int j = 0; j \u0026lt; 26 ; j++) { if (ans[i][j]) res++; } } System.out.println(res); for (int i = 0; i \u0026lt; 26; i++) { for (int j = 0; j \u0026lt; 26 ; j++) { if (ans[i][j]) { System.out.println(String.format(\u0026#34;%c%c%c\u0026#34;, (char) (i + \u0026#39;a\u0026#39;), (char) (j + \u0026#39;a\u0026#39;), (char) (j + \u0026#39;a\u0026#39;))); } } } } public static void update(int l,int r,int v){ l=Math.max(l,0); r=Math.min(r,n-1); for (int i = l; i+2 \u0026lt;= r ; i++) { char a=s[i],b=s[i+1],c=s[i+2]; if(a!=b\u0026amp;\u0026amp;b==c){ cnt[a][b]+=v; if (cnt[a][b]\u0026gt;=m) ans[a][b]=true; } } } } ","date":"2025-03-24T00:00:00Z","image":"https://yanbin582.github.io/p/acwing-6122.-%E5%86%9C%E5%A4%AB%E7%BA%A6%E7%BF%B0%E7%9A%84%E5%A5%B6%E9%85%AA%E5%9D%97/image_hu7343995253115549451.png","permalink":"https://yanbin582.github.io/p/acwing-6122.-%E5%86%9C%E5%A4%AB%E7%BA%A6%E7%BF%B0%E7%9A%84%E5%A5%B6%E9%85%AA%E5%9D%97/","title":"AcWing 6122. 农夫约翰的奶酪块"},{"content":"题目 博主解题思路： ​\t首先熟读题目后，发现要求的是，一段定长字符串中的abb形式的定长字串，如果定长字串的数量大于等于F的话，那么就可以列为一组答案，值得注意的是，字符串中可能存在至多一个字符与原始字符串不用，也就是说，可以在字串中更改一个字符，如果字符更改后的关联的定长字串的数量能大于等于F，那么也可以列入答案当中，那么思路就很明显了，首先，我们定义一个cnt数组，用来统计原字符串中的定长字串数量，再依次改变原字符串中的每一个字符，共有25种更改情况，每次改变字符，都会改变三个定长字串，如：\n值得注意的是，每次我们更改字符之前，我们将原来的关联的三个字串数量-1，这样子我们修改之后，得到新字串，加入到字串数量中，才能有效的判断是否出现了有效的答案字串，不然就会多加1，在改变字符之后，对应的三个新字串数量加一，判断是否有答案字串，如果有答案字串，那么就标记一下（开辟一个新的数组来记录答案字串），更新完之后，再减去字串数量-1，最后恢复现场，将原字符放回原位，并更新原字串数量，这样子就能达到至多只有一个字符改变的效果，最后统计答案字串数量，并输出答案子串\n说实话这个题目难度对目前的我来说难度还是比较大，但是搞懂本题之后，对我的思维拓展还是比较大，模拟题目或者需要重复执行类似操作的题目，可以开辟一个更新函数来重复操作，直观并且更为简洁\n答案： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import java.util.Scanner; public class Main{ private static final int N = 20010; // N 设为静态常量 private static final int M = 26; private static Integer n; private static Integer m; private static char[] s; private static int[][] cnt=new int[M][M]; private static boolean[][] ans=new boolean[M][M]; public static void main(String agrs[]){ Scanner sc=new Scanner(System.in); n =sc.nextInt(); m=sc.nextInt(); sc.nextLine(); String S=sc.nextLine(); s=S.toCharArray(); //先将字符转换为数字 for (int i = 0; i \u0026lt; s.length; i++) s[i]-=\u0026#39;a\u0026#39;; //先统计原字符串中的哞叫可能 update(0,n-1,1); for (int i = 0; i \u0026lt; n; i++) { char t=s[i]; update(i-2,i+2,-1); for (int j = 0; j \u0026lt; 26; j++) { if (j!=t){ s[i]= (char) j; update(i-2,i+2,1); update(i-2,i+2,-1); } } s[i]=t; update(i-2,i+2,1); } int res=0; for (int i = 0; i \u0026lt; 26; i++) { for (int j = 0; j \u0026lt; 26 ; j++) { if (ans[i][j]) res++; } } System.out.println(res); for (int i = 0; i \u0026lt; 26; i++) { for (int j = 0; j \u0026lt; 26 ; j++) { if (ans[i][j]) { System.out.println(String.format(\u0026#34;%c%c%c\u0026#34;, (char) (i + \u0026#39;a\u0026#39;), (char) (j + \u0026#39;a\u0026#39;), (char) (j + \u0026#39;a\u0026#39;))); } } } } public static void update(int l,int r,int v){ l=Math.max(l,0); r=Math.min(r,n-1); for (int i = l; i+2 \u0026lt;= r ; i++) { char a=s[i],b=s[i+1],c=s[i+2]; if(a!=b\u0026amp;\u0026amp;b==c){ cnt[a][b]+=v; if (cnt[a][b]\u0026gt;=m) ans[a][b]=true; } } } } ","date":"2025-03-24T00:00:00Z","image":"https://yanbin582.github.io/p/acwing-6123.-%E5%93%9E%E5%8F%AB%E6%97%B6%E9%97%B4/image_hu7343995253115549451.png","permalink":"https://yanbin582.github.io/p/acwing-6123.-%E5%93%9E%E5%8F%AB%E6%97%B6%E9%97%B4/","title":"AcWing 6123. 哞叫时间"},{"content":"1.****快速入门MybaitsPlus 快速开始 比如我们要实现User表的CRUD，只需要下面几步：\n引入MybatisPlus依赖 定义Mapper 引入依赖 MybatisPlus提供了starter，实现了自动Mybatis以及MybatisPlus的自动装配功能，坐标如下：\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.3.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 由于这个starter包含对mybatis的自动装配，因此完全可以替换掉Mybatis的starter。\n定义Mapper 为了简化单表CRUD，MybatisPlus提供了一个基础的BaseMapper接口，其中已经实现了单表的CRUD：\n因此我们自定义的Mapper只要实现了这个BaseMapper，就无需自己实现单表CRUD了。 修改mp-demo中的com.itheima.mp.mapper包下的UserMapper接口，让其继承BaseMapper：\n代码如下：\n1 2 3 4 5 6 7 package com.itheima.mp.mapper; import com.baomidou.mybatisplus.core.mapper.BaseMapper; import com.itheima.mp.domain.po.User; public interface UserMapper extends BaseMapper\u0026lt;User\u0026gt; { } 测试 新建一个测试类，编写几个单元测试，测试基本的CRUD功能：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 @SpringBootTest class UserMapperTest { @Autowired private UserMapper userMapper; @Test void testInsert() { User user = new User(); user.setId(5L); user.setUsername(\u0026#34;Lucy\u0026#34;); user.setPassword(\u0026#34;123\u0026#34;); user.setPhone(\u0026#34;18688990011\u0026#34;); user.setBalance(200); user.setInfo(\u0026#34;{\\\u0026#34;age\\\u0026#34;: 24, \\\u0026#34;intro\\\u0026#34;: \\\u0026#34;英文老师\\\u0026#34;, \\\u0026#34;gender\\\u0026#34;: \\\u0026#34;female\\\u0026#34;}\u0026#34;); user.setCreateTime(LocalDateTime.now()); user.setUpdateTime(LocalDateTime.now()); userMapper.insert(user); } @Test void testSelectById() { User user = userMapper.selectById(5L); System.out.println(\u0026#34;user = \u0026#34; + user); } @Test void testSelectByIds() { List\u0026lt;User\u0026gt; users = userMapper.selectBatchIds(List.of(1L, 2L, 3L, 4L, 5L)); users.forEach(System.out::println); } @Test void testUpdateById() { User user = new User(); user.setId(5L); user.setBalance(20000); userMapper.updateById(user); } @Test void testDelete() { userMapper.deleteById(5L); } } 只需要继承BaseMapper就能省去所有的单表CRUD，是不是非常简单！\n2.常见注解** 在刚刚的入门案例中，我们仅仅引入了依赖，继承了BaseMapper就能使用MybatisPlus，非常简单。但是问题来了： MybatisPlus如何知道我们要查询的是哪张表？表中有哪些字段呢？\n大家回忆一下，UserMapper在继承BaseMapper的时候指定了一个泛型：\n泛型中的User就是与数据库对应的PO.\nMybatisPlus就是根据PO实体的信息来推断出表的信息，从而生成SQL的。默认情况下：\nMybatisPlus会把PO实体的类名驼峰转下划线作为表名 MybatisPlus会把PO实体的所有变量名驼峰转下划线作为表的字段名，并根据变量类型推断字段类型 MybatisPlus会把名为id的字段作为主键 但很多情况下，默认的实现与实际场景不符，因此MybatisPlus提供了一些注解便于我们声明表信息。\n**@**TableName 说明：\n描述：表名注解，标识实体类对应的表 使用位置：实体类 示例：\n1 2 3 4 5 @TableName(\u0026#34;user\u0026#34;) public class User { private Long id; private String name; } TableName注解除了指定表名以外，还可以指定很多其它属性：\n属性 类型 必须指定 默认值 描述 value String 否 \u0026quot;\u0026quot; 表名 schema String 否 \u0026quot;\u0026quot; schema keepGlobalPrefix boolean 否 false 是否保持使用全局的 tablePrefix 的值（当全局 tablePrefix 生效时） resultMap String 否 \u0026quot;\u0026quot; xml 中 resultMap 的 id（用于满足特定类型的实体类对象绑定） autoResultMap boolean 否 false 是否自动构建 resultMap 并使用（如果设置 resultMap 则不会进行 resultMap 的自动构建与注入） excludeProperty String[] 否 {} 需要排除的属性名 @since 3.3.1 @TableId 说明：\n描述：主键注解，标识实体类中的主键字段 使用位置：实体类的主键字段 示例：\n1 2 3 4 5 6 @TableName(\u0026#34;user\u0026#34;) public class User { @TableId private Long id; private String name; } TableId注解支持两个属性：\n属性 类型 必须指定 默认值 描述 value String 否 \u0026quot;\u0026quot; 表名 type Enum 否 IdType.NONE 指定主键类型 IdType支持的类型有：\n值 描述 AUTO 数据库 ID 自增 NONE 无状态，该类型为未设置主键类型（注解里等于跟随全局，全局里约等于 INPUT） INPUT insert 前自行 set 主键值 ASSIGN_ID 分配 ID(主键类型为 Number(Long 和 Integer)或 String)(since 3.3.0),使用接口IdentifierGenerator的方法nextId(默认实现类为DefaultIdentifierGenerator雪花算法) ASSIGN_UUID 分配 UUID,主键类型为 String(since 3.3.0),使用接口IdentifierGenerator的方法nextUUID(默认 default 方法) ID_WORKER 分布式全局唯一 ID 长整型类型(please use ASSIGN_ID) UUID 32 位 UUID 字符串(please use ASSIGN_UUID) ID_WORKER_STR 分布式全局唯一 ID 字符串类型(please use ASSIGN_ID) 这里比较常见的有三种：\nAUTO：利用数据库的id自增长 INPUT：手动生成id ASSIGN_ID：雪花算法生成Long类型的全局唯一id，这是默认的ID策略 @TableField 说明：\n描述：普通字段注解\n示例：\n1 2 3 4 5 6 7 8 9 10 11 @TableName(\u0026#34;user\u0026#34;) public class User { @TableId private Long id; private String name; private Integer age; @TableField(is_married\u0026#34;) private Boolean isMarried; @TableField(\u0026#34;`concat`\u0026#34;) private String concat; } 一般情况下我们并不需要给字段添加@TableField注解，一些特殊情况除外：\n成员变量名与数据库字段名不一致 成员变量是以isXXX命名，按照JavaBean的规范，MybatisPlus识别字段时会把is去除，这就导致与数据库不符。 成员变量名与数据库一致，但是与数据库的关键字冲突。使用@TableField注解给字段名添加转义字符：```` 支持的其它属性如下：\n属性 类型 必填 默认值 描述 value String 否 \u0026quot;\u0026quot; 数据库字段名 exist boolean 否 true 是否为数据库表字段 condition String 否 \u0026quot;\u0026quot; 字段 where 实体查询比较条件，有值设置则按设置的值为准，没有则为默认全局的 %s=#{%s}，参考(opens new window) update String 否 \u0026quot;\u0026quot; 字段 update set 部分注入，例如：当在version字段上注解update=\u0026quot;%s+1\u0026quot; 表示更新时会 set version=version+1 （该属性优先级高于 el 属性） insertStrategy Enum 否 FieldStrategy.DEFAULT 举例：NOT_NULL insert into table_a(column) values (#{columnProperty}) updateStrategy Enum 否 FieldStrategy.DEFAULT 举例：IGNORED update table_a set column=#{columnProperty} whereStrategy Enum 否 FieldStrategy.DEFAULT 举例：NOT_EMPTY where column=#{columnProperty} fill Enum 否 FieldFill.DEFAULT 字段自动填充策略 select boolean 否 true 是否进行 select 查询 keepGlobalFormat boolean 否 false 是否保持使用全局的 format 进行处理 jdbcType JdbcType 否 JdbcType.UNDEFINED JDBC 类型 (该默认值不代表会按照该值生效) typeHandler TypeHander 否 类型处理器 (该默认值不代表会按照该值生效) numericScale String 否 \u0026quot;\u0026quot; 指定小数点后保留的位数 常见配置 MybatisPlus也支持基于yaml文件的自定义配置，详见官方文档：\nhttps://baomidou.com/reference/\n大多数的配置都有默认值，因此我们都无需配置。但还有一些是没有默认值的，例如:\n实体类的别名扫描包 全局id类型 1 2 3 4 5 mybatis-plus: type-aliases-package: com.itheima.mp.domain.po global-config: db-config: id-type: auto # 全局id类型为自增长 需要注意的是，MyBatisPlus也支持手写SQL的，而mapper文件的读取地址可以自己配置：\n1 2 mybatis-plus: mapper-locations: \u0026#34;classpath*:/mapper/**/*.xml\u0026#34; # Mapper.xml文件地址，当前这个是默认值。 可以看到默认值是classpath*:/mapper/**/*.xml，也就是说我们只要把mapper.xml文件放置这个目录下就一定会被加载。\n例如，我们新建一个UserMapper.xml文件：\n然后在其中定义一个方法：\n1 2 3 4 5 6 7 8 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.itheima.mp.mapper.UserMapper\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;queryById\u0026#34; resultType=\u0026#34;User\u0026#34;\u0026gt; SELECT * FROM user WHERE id = #{id} \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 然后在测试类UserMapperTest中测试该方法：\n1 2 3 4 5 @Test void testQuery() { User user = userMapper.queryById(1L); System.out.println(\u0026#34;user = \u0026#34; + user); } 2.核心功能 刚才的案例中都是以id为条件的简单CRUD，一些复杂条件的SQL语句就要用到一些更高级的功能了。\n条件构造器 除了新增以外，修改、删除、查询的SQL语句都需要指定where条件。因此BaseMapper中提供的相关方法除了以id作为where条件以外，还支持更加复杂的where条件。\n参数中的Wrapper就是条件构造的抽象类，其下有很多默认实现，继承关系如图：\nWrapper的子类AbstractWrapper提供了where中包含的所有条件构造方法：\n而QueryWrapper在AbstractWrapper的基础上拓展了一个select方法，允许指定查询字段：\n而UpdateWrapper在AbstractWrapper的基础上拓展了一个set方法，允许指定SQL中的SET部分：\n接下来，我们就来看看如何利用Wrapper实现复杂查询。\nQueryWrapper 无论是修改、删除、查询，都可以使用QueryWrapper来构建查询条件。接下来看一些例子： 查询：查询出名字中带o的，存款大于等于1000元的人。代码如下：\n1 2 3 4 5 6 7 8 9 10 11 @Test void testQueryWrapper() { // 1.构建查询条件 where name like \u0026#34;%o%\u0026#34; AND balance \u0026gt;= 1000 QueryWrapper\u0026lt;User\u0026gt; wrapper = new QueryWrapper\u0026lt;User\u0026gt;() .select(\u0026#34;id\u0026#34;, \u0026#34;username\u0026#34;, \u0026#34;info\u0026#34;, \u0026#34;balance\u0026#34;) .like(\u0026#34;username\u0026#34;, \u0026#34;o\u0026#34;) .ge(\u0026#34;balance\u0026#34;, 1000); // 2.查询数据 List\u0026lt;User\u0026gt; users = userMapper.selectList(wrapper); users.forEach(System.out::println); } 更新：更新用户名为jack的用户的余额为2000，代码如下：\n1 2 3 4 5 6 7 8 9 @Test void testUpdateByQueryWrapper() { // 1.构建查询条件 where name = \u0026#34;Jack\u0026#34; QueryWrapper\u0026lt;User\u0026gt; wrapper = new QueryWrapper\u0026lt;User\u0026gt;().eq(\u0026#34;username\u0026#34;, \u0026#34;Jack\u0026#34;); // 2.更新数据，user中非null字段都会作为set语句 User user = new User(); user.setBalance(2000); userMapper.update(user, wrapper); } UpdateWrapper 基于BaseMapper中的update方法更新时只能直接赋值，对于一些复杂的需求就难以实现。 例如：更新id为1,2,4的用户的余额，扣200，对应的SQL应该是：\n1 UPDATE user SET balance = balance - 200 WHERE id in (1, 2, 4) SET的赋值结果是基于字段现有值的，这个时候就要利用UpdateWrapper中的setSql功能了：\n1 2 3 4 5 6 7 8 9 10 11 @Test void testUpdateWrapper() { List\u0026lt;Long\u0026gt; ids = List.of(1L, 2L, 4L); // 1.生成SQL UpdateWrapper\u0026lt;User\u0026gt; wrapper = new UpdateWrapper\u0026lt;User\u0026gt;() .setSql(\u0026#34;balance = balance - 200\u0026#34;) // SET balance = balance - 200 .in(\u0026#34;id\u0026#34;, ids); // WHERE id in (1, 2, 4) // 2.更新，注意第一个参数可以给null，也就是不填更新字段和数据， // 而是基于UpdateWrapper中的setSQL来更新 userMapper.update(null, wrapper); } ****LambdaQueryWrapper 无论是QueryWrapper还是UpdateWrapper在构造条件的时候都需要写死字段名称，会出现字符串魔法值。这在编程规范中显然是不推荐的。 那怎么样才能不写字段名，又能知道字段名呢？\n其中一种办法是基于变量的gettter方法结合反射技术。因此我们只要将条件对应的字段的getter方法传递给MybatisPlus，它就能计算出对应的变量名了。而传递方法可以使用JDK8中的方法引用和Lambda表达式。 因此MybatisPlus又提供了一套基于Lambda的Wrapper，包含两个：\nLambdaQueryWrapper LambdaUpdateWrapper 分别对应QueryWrapper和UpdateWrapper\n其使用方式如下：\n1 2 3 4 5 6 7 8 9 10 11 12 @Test void testLambdaQueryWrapper() { // 1.构建条件 WHERE username LIKE \u0026#34;%o%\u0026#34; AND balance \u0026gt;= 1000 QueryWrapper\u0026lt;User\u0026gt; wrapper = new QueryWrapper\u0026lt;\u0026gt;(); wrapper.lambda() .select(User::getId, User::getUsername, User::getInfo, User::getBalance) .like(User::getUsername, \u0026#34;o\u0026#34;) .ge(User::getBalance, 1000); // 2.查询 List\u0026lt;User\u0026gt; users = userMapper.selectList(wrapper); users.forEach(System.out::println); } 自定义SQL** 在演示UpdateWrapper的案例中，我们在代码中编写了更新的SQL语句：\n这种写法在某些企业也是不允许的，因为SQL语句最好都维护在持久层，而不是业务层。就当前案例来说，由于条件是in语句，只能将SQL写在Mapper.xml文件，利用foreach来生成动态SQL。 这实在是太麻烦了。假如查询条件更复杂，动态SQL的编写也会更加复杂。\n所以，MybatisPlus提供了自定义SQL功能，可以让我们利用Wrapper生成查询条件，再结合Mapper.xml编写SQL\n2.2.1.基本用法 以当前案例来说，我们可以这样写：\n1 2 3 4 5 6 7 8 9 @Test void testCustomWrapper() { // 1.准备自定义查询条件 List\u0026lt;Long\u0026gt; ids = List.of(1L, 2L, 4L); QueryWrapper\u0026lt;User\u0026gt; wrapper = new QueryWrapper\u0026lt;User\u0026gt;().in(\u0026#34;id\u0026#34;, ids); // 2.调用mapper的自定义方法，直接传递Wrapper userMapper.deductBalanceByIds(200, wrapper); } 然后在UserMapper中自定义SQL：\n1 2 3 4 5 6 7 8 9 10 11 12 package com.itheima.mp.mapper; import com.baomidou.mybatisplus.core.mapper.BaseMapper; import com.itheima.mp.domain.po.User; import org.apache.ibatis.annotations.Param; import org.apache.ibatis.annotations.Update; import org.apache.ibatis.annotations.Param; public interface UserMapper extends BaseMapper\u0026lt;User\u0026gt; { @Select(\u0026#34;UPDATE user SET balance = balance - #{money} ${ew.customSqlSegment}\u0026#34;) void deductBalanceByIds(@Param(\u0026#34;money\u0026#34;) int money, @Param(\u0026#34;ew\u0026#34;) QueryWrapper\u0026lt;User\u0026gt; wrapper); } 这样就省去了编写复杂查询条件的烦恼了。\n2.2.2.多表关联 理论上来讲MyBatisPlus是不支持多表查询的，不过我们可以利用Wrapper中自定义条件结合自定义SQL来实现多表查询的效果。 例如，我们要查询出所有收货地址在北京的并且用户id在1、2、4之中的用户 要是自己基于mybatis实现SQL，大概是这样的：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;select id=\u0026#34;queryUserByIdAndAddr\u0026#34; resultType=\u0026#34;com.itheima.mp.domain.po.User\u0026#34;\u0026gt; SELECT * FROM user u INNER JOIN address a ON u.id = a.user_id WHERE u.id \u0026lt;foreach collection=\u0026#34;ids\u0026#34; separator=\u0026#34;,\u0026#34; item=\u0026#34;id\u0026#34; open=\u0026#34;IN (\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; #{id} \u0026lt;/foreach\u0026gt; AND a.city = #{city} \u0026lt;/select\u0026gt; 可以看出其中最复杂的就是WHERE条件的编写，如果业务复杂一些，这里的SQL会更变态。\n但是基于自定义SQL结合Wrapper的玩法，我们就可以利用Wrapper来构建查询条件，然后手写SELECT及FROM部分，实现多表查询。\n查询条件这样来构建：\n1 2 3 4 5 6 7 8 9 10 11 12 @Test void testCustomJoinWrapper() { // 1.准备自定义查询条件 QueryWrapper\u0026lt;User\u0026gt; wrapper = new QueryWrapper\u0026lt;User\u0026gt;() .in(\u0026#34;u.id\u0026#34;, List.of(1L, 2L, 4L)) .eq(\u0026#34;a.city\u0026#34;, \u0026#34;北京\u0026#34;); // 2.调用mapper的自定义方法 List\u0026lt;User\u0026gt; users = userMapper.queryUserByWrapper(wrapper); users.forEach(System.out::println); } 然后在UserMapper中自定义方法：\n1 2 @Select(\u0026#34;SELECT u.* FROM user u INNER JOIN address a ON u.id = a.user_id ${ew.customSqlSegment}\u0026#34;) List\u0026lt;User\u0026gt; queryUserByWrapper(@Param(\u0026#34;ew\u0026#34;)QueryWrapper\u0026lt;User\u0026gt; wrapper); 当然，也可以在UserMapper.xml中写SQL：\n1 2 3 \u0026lt;select id=\u0026#34;queryUserByIdAndAddr\u0026#34; resultType=\u0026#34;com.itheima.mp.domain.po.User\u0026#34;\u0026gt; SELECT * FROM user u INNER JOIN address a ON u.id = a.user_id ${ew.customSqlSegment} \u0026lt;/select\u0026gt; **2.3.**Service接口 MybatisPlus不仅提供了BaseMapper，还提供了通用的Service接口及默认实现，封装了一些常用的service模板方法。 通用接口为IService，默认实现为ServiceImpl，其中封装的方法可以分为以下几类：\nsave：新增 remove：删除 update：更新 get：查询单个结果 list：查询集合结果 count：计数 page：分页查询 **2.3.1.**CRUD 我们先俩看下基本的CRUD接口。 新增：\nsave是新增单个元素 saveBatch是批量新增 saveOrUpdate是根据id判断，如果数据存在就更新，不存在则新增 saveOrUpdateBatch是批量的新增或修改 删除：\nremoveById：根据id删除 removeByIds：根据id批量删除 removeByMap：根据Map中的键值对为条件删除 remove(Wrapper\u0026lt;T\u0026gt;)：根据Wrapper条件删除 ~~removeBatchByIds~~：暂不支持 修改：\nupdateById：根据id修改 update(Wrapper\u0026lt;T\u0026gt;)：根据UpdateWrapper修改，Wrapper中包含set和where部分 update(T，Wrapper\u0026lt;T\u0026gt;)：按照T内的数据修改与Wrapper匹配到的数据 updateBatchById：根据id批量修改 Get：\ngetById：根据id查询1条数据 getOne(Wrapper\u0026lt;T\u0026gt;)：根据Wrapper查询1条数据 getBaseMapper：获取Service内的BaseMapper实现，某些时候需要直接调用Mapper内的自定义SQL时可以用这个方法获取到Mapper List：\nlistByIds：根据id批量查询 list(Wrapper\u0026lt;T\u0026gt;)：根据Wrapper条件查询多条数据 list()：查询所有 Count：\ncount()：统计所有数量 count(Wrapper\u0026lt;T\u0026gt;)：统计符合Wrapper条件的数据数量 getBaseMapper： 当我们在service中要调用Mapper中自定义SQL时，就必须获取service对应的Mapper，就可以通过这个方法：\n2.3.2.基本用法 由于Service中经常需要定义与业务有关的自定义方法，因此我们不能直接使用IService，而是自定义Service接口，然后继承IService以拓展方法。同时，让自定义的Service实现类继承ServiceImpl，这样就不用自己实现IService中的接口了。\n首先，定义IUserService，继承IService：\n1 2 3 4 5 6 7 8 package com.itheima.mp.service; import com.baomidou.mybatisplus.extension.service.IService; import com.itheima.mp.domain.po.User; public interface IUserService extends IService\u0026lt;User\u0026gt; { // 拓展自定义方法 } 然后，编写UserServiceImpl类，继承ServiceImpl，实现UserService：\n1 2 3 4 5 6 7 8 9 10 11 12 package com.itheima.mp.service.impl; import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl; import com.itheima.mp.domain.po.User; import com.itheima.mp.domain.po.service.IUserService; import com.itheima.mp.mapper.UserMapper; import org.springframework.stereotype.Service; @Service public class UserServiceImpl extends ServiceImpl\u0026lt;UserMapper, User\u0026gt; implements IUserService { } 项目结构如下：\n接下来，我们快速实现下面4个接口：\n编号 接口 请求方式 请求路径 请求参数 返回值 1 新增用户 POST /users 用户表单实体 无 2 删除用户 DELETE /users/{id} 用户id 无 3 根据id查询用户 GET /users/{id} 用户id 用户VO 4 根据id批量查询 GET /users 用户id集合 用户VO集合 首先，我们在项目中引入几个依赖：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!--swagger--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.xiaoymin\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;knife4j-openapi2-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--web--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 然后需要配置swagger信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 knife4j: enable: true openapi: title: 用户管理接口文档 description: \u0026#34;用户管理接口文档\u0026#34; email: zhanghuyi@itcast.cn concat: 虎哥 url: https://www.itcast.cn version: v1.0.0 group: default: group-name: default api-rule: package api-rule-resources: - com.itheima.mp.controller 然后，接口需要两个实体：\nUserFormDTO：代表新增时的用户表单 UserVO：代表查询的返回结果 首先是UserFormDTO：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package com.itheima.mp.domain.dto; import com.baomidou.mybatisplus.annotation.TableField; import com.baomidou.mybatisplus.extension.handlers.JacksonTypeHandler; import io.swagger.annotations.ApiModel; import io.swagger.annotations.ApiModelProperty; import lombok.Data; @Data @ApiModel(description = \u0026#34;用户表单实体\u0026#34;) public class UserFormDTO { @ApiModelProperty(\u0026#34;id\u0026#34;) private Long id; @ApiModelProperty(\u0026#34;用户名\u0026#34;) private String username; @ApiModelProperty(\u0026#34;密码\u0026#34;) private String password; @ApiModelProperty(\u0026#34;注册手机号\u0026#34;) private String phone; @ApiModelProperty(\u0026#34;详细信息，JSON风格\u0026#34;) private String info; @ApiModelProperty(\u0026#34;账户余额\u0026#34;) private Integer balance; } 然后是UserVO：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package com.itheima.mp.domain.vo; import io.swagger.annotations.ApiModel; import io.swagger.annotations.ApiModelProperty; import lombok.Data; @Data @ApiModel(description = \u0026#34;用户VO实体\u0026#34;) public class UserVO { @ApiModelProperty(\u0026#34;用户id\u0026#34;) private Long id; @ApiModelProperty(\u0026#34;用户名\u0026#34;) private String username; @ApiModelProperty(\u0026#34;详细信息\u0026#34;) private String info; @ApiModelProperty(\u0026#34;使用状态（1正常 2冻结）\u0026#34;) private Integer status; @ApiModelProperty(\u0026#34;账户余额\u0026#34;) private Integer balance; } 最后，按照Restful风格编写Controller接口方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 package com.itheima.mp.controller; import cn.hutool.core.bean.BeanUtil; import com.itheima.mp.domain.dto.UserFormDTO; import com.itheima.mp.domain.po.User; import com.itheima.mp.domain.vo.UserVO; import com.itheima.mp.service.IUserService; import io.swagger.annotations.Api; import io.swagger.annotations.ApiOperation; import lombok.RequiredArgsConstructor; import org.springframework.web.bind.annotation.*; import java.util.List; @Api(tags = \u0026#34;用户管理接口\u0026#34;) @RequiredArgsConstructor @RestController @RequestMapping(\u0026#34;users\u0026#34;) public class UserController { private final IUserService userService; @PostMapping @ApiOperation(\u0026#34;新增用户\u0026#34;) public void saveUser(@RequestBody UserFormDTO userFormDTO){ // 1.转换DTO为PO User user = BeanUtil.copyProperties(userFormDTO, User.class); // 2.新增 userService.save(user); } @DeleteMapping(\u0026#34;/{id}\u0026#34;) @ApiOperation(\u0026#34;删除用户\u0026#34;) public void removeUserById(@PathVariable(\u0026#34;id\u0026#34;) Long userId){ userService.removeById(userId); } @GetMapping(\u0026#34;/{id}\u0026#34;) @ApiOperation(\u0026#34;根据id查询用户\u0026#34;) public UserVO queryUserById(@PathVariable(\u0026#34;id\u0026#34;) Long userId){ // 1.查询用户 User user = userService.getById(userId); // 2.处理vo return BeanUtil.copyProperties(user, UserVO.class); } @GetMapping @ApiOperation(\u0026#34;根据id集合查询用户\u0026#34;) public List\u0026lt;UserVO\u0026gt; queryUserByIds(@RequestParam(\u0026#34;ids\u0026#34;) List\u0026lt;Long\u0026gt; ids){ // 1.查询用户 List\u0026lt;User\u0026gt; users = userService.listByIds(ids); // 2.处理vo return BeanUtil.copyToList(users, UserVO.class); } } 可以看到上述接口都直接在controller即可实现，无需编写任何service代码，非常方便。\n不过，一些带有业务逻辑的接口则需要在service中自定义实现了。例如下面的需求：\n根据id扣减用户余额 这看起来是个简单修改功能，只要修改用户余额即可。但这个业务包含一些业务逻辑处理：\n判断用户状态是否正常 判断用户余额是否充足 这些业务逻辑都要在service层来做，另外更新余额需要自定义SQL，要在mapper中来实现。因此，我们除了要编写controller以外，具体的业务还要在service和mapper中编写。\n首先在UserController中定义一个方法：\n1 2 3 4 5 @PutMapping(\u0026#34;{id}/deduction/{money}\u0026#34;) @ApiOperation(\u0026#34;扣减用户余额\u0026#34;) public void deductBalance(@PathVariable(\u0026#34;id\u0026#34;) Long id, @PathVariable(\u0026#34;money\u0026#34;)Integer money){ userService.deductBalance(id, money); } 然后是UserService接口：\n1 2 3 4 5 6 7 8 package com.itheima.mp.service; import com.baomidou.mybatisplus.extension.service.IService; import com.itheima.mp.domain.po.User; public interface IUserService extends IService\u0026lt;User\u0026gt; { void deductBalance(Long id, Integer money); } 最后是UserServiceImpl实现类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package com.itheima.mp.service.impl; import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl; import com.itheima.mp.domain.po.User; import com.itheima.mp.mapper.UserMapper; import com.itheima.mp.service.IUserService; import org.springframework.stereotype.Service; @Service public class UserServiceImpl extends ServiceImpl\u0026lt;UserMapper, User\u0026gt; implements IUserService { @Override public void deductBalance(Long id, Integer money) { // 1.查询用户 User user = getById(id); // 2.判断用户状态 if (user == null || user.getStatus() == 2) { throw new RuntimeException(\u0026#34;用户状态异常\u0026#34;); } // 3.判断用户余额 if (user.getBalance() \u0026lt; money) { throw new RuntimeException(\u0026#34;用户余额不足\u0026#34;); } // 4.扣减余额 baseMapper.deductMoneyById(id, money); } } 最后是mapper：\n1 2 @Update(\u0026#34;UPDATE user SET balance = balance - #{money} WHERE id = #{id}\u0026#34;) void deductMoneyById(@Param(\u0026#34;id\u0026#34;) Long id, @Param(\u0026#34;money\u0026#34;) Integer money); **2.3.3.**Lambda IService中还提供了Lambda功能来简化我们的复杂查询及更新功能。我们通过两个案例来学习一下。\n案例一：实现一个根据复杂条件查询用户的接口，查询条件如下：\nname：用户名关键字，可以为空 status：用户状态，可以为空 minBalance：最小余额，可以为空 maxBalance：最大余额，可以为空 可以理解成一个用户的后台管理界面，管理员可以自己选择条件来筛选用户，因此上述条件不一定存在，需要做判断。\n我们首先需要定义一个查询条件实体，UserQuery实体：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package com.itheima.mp.domain.query; import io.swagger.annotations.ApiModel; import io.swagger.annotations.ApiModelProperty; import lombok.Data; @Data @ApiModel(description = \u0026#34;用户查询条件实体\u0026#34;) public class UserQuery { @ApiModelProperty(\u0026#34;用户名关键字\u0026#34;) private String name; @ApiModelProperty(\u0026#34;用户状态：1-正常，2-冻结\u0026#34;) private Integer status; @ApiModelProperty(\u0026#34;余额最小值\u0026#34;) private Integer minBalance; @ApiModelProperty(\u0026#34;余额最大值\u0026#34;) private Integer maxBalance; } 接下来我们在UserController中定义一个controller方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @GetMapping(\u0026#34;/list\u0026#34;) @ApiOperation(\u0026#34;根据id集合查询用户\u0026#34;) public List\u0026lt;UserVO\u0026gt; queryUsers(UserQuery query){ // 1.组织条件 String username = query.getName(); Integer status = query.getStatus(); Integer minBalance = query.getMinBalance(); Integer maxBalance = query.getMaxBalance(); LambdaQueryWrapper\u0026lt;User\u0026gt; wrapper = new QueryWrapper\u0026lt;User\u0026gt;().lambda() .like(username != null, User::getUsername, username) .eq(status != null, User::getStatus, status) .ge(minBalance != null, User::getBalance, minBalance) .le(maxBalance != null, User::getBalance, maxBalance); // 2.查询用户 List\u0026lt;User\u0026gt; users = userService.list(wrapper); // 3.处理vo return BeanUtil.copyToList(users, UserVO.class); } 在组织查询条件的时候，我们加入了 username != null 这样的参数，意思就是当条件成立时才会添加这个查询条件，类似Mybatis的mapper.xml文件中的\u0026lt;if\u0026gt;标签。这样就实现了动态查询条件效果了。\n不过，上述条件构建的代码太麻烦了。 因此Service中对LambdaQueryWrapper和LambdaUpdateWrapper的用法进一步做了简化。我们无需自己通过new的方式来创建Wrapper，而是直接调用lambdaQuery和lambdaUpdate方法：\n基于Lambda查询：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @GetMapping(\u0026#34;/list\u0026#34;) @ApiOperation(\u0026#34;根据id集合查询用户\u0026#34;) public List\u0026lt;UserVO\u0026gt; queryUsers(UserQuery query){ // 1.组织条件 String username = query.getName(); Integer status = query.getStatus(); Integer minBalance = query.getMinBalance(); Integer maxBalance = query.getMaxBalance(); // 2.查询用户 List\u0026lt;User\u0026gt; users = userService.lambdaQuery() .like(username != null, User::getUsername, username) .eq(status != null, User::getStatus, status) .ge(minBalance != null, User::getBalance, minBalance) .le(maxBalance != null, User::getBalance, maxBalance) .list(); // 3.处理vo return BeanUtil.copyToList(users, UserVO.class); } 可以发现lambdaQuery方法中除了可以构建条件，还需要在链式编程的最后添加一个list()，这是在告诉MP我们的调用结果需要是一个list集合。这里不仅可以用list()，可选的方法有：\n.one()：最多1个结果 .list()：返回集合结果 .count()：返回计数结果 MybatisPlus会根据链式编程的最后一个方法来判断最终的返回结果。\n与lambdaQuery方法类似，IService中的lambdaUpdate方法可以非常方便的实现复杂更新业务。\n例如下面的需求：\n需求：改造根据id修改用户余额的接口，要求如下\n如果扣减后余额为0，则将用户status修改为冻结状态（2） 也就是说我们在扣减用户余额时，需要对用户剩余余额做出判断，如果发现剩余余额为0，则应该将status修改为2，这就是说update语句的set部分是动态的。\n实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Override @Transactional public void deductBalance(Long id, Integer money) { // 1.查询用户 User user = getById(id); // 2.校验用户状态 if (user == null || user.getStatus() == 2) { throw new RuntimeException(\u0026#34;用户状态异常！\u0026#34;); } // 3.校验余额是否充足 if (user.getBalance() \u0026lt; money) { throw new RuntimeException(\u0026#34;用户余额不足！\u0026#34;); } // 4.扣减余额 update tb_user set balance = balance - ? int remainBalance = user.getBalance() - money; lambdaUpdate() .set(User::getBalance, remainBalance) // 更新余额 .set(remainBalance == 0, User::getStatus, 2) // 动态判断，是否更新status .eq(User::getId, id) .eq(User::getBalance, user.getBalance()) // 乐观锁 .update(); } **2.3.4.**批量新增 IService中的批量新增功能使用起来非常方便，但有一点注意事项，我们先来测试一下。 首先我们测试逐条插入数据：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Test void testSaveOneByOne() { long b = System.currentTimeMillis(); for (int i = 1; i \u0026lt;= 100000; i++) { userService.save(buildUser(i)); } long e = System.currentTimeMillis(); System.out.println(\u0026#34;耗时：\u0026#34; + (e - b)); } private User buildUser(int i) { User user = new User(); user.setUsername(\u0026#34;user_\u0026#34; + i); user.setPassword(\u0026#34;123\u0026#34;); user.setPhone(\u0026#34;\u0026#34; + (18688190000L + i)); user.setBalance(2000); user.setInfo(\u0026#34;{\\\u0026#34;age\\\u0026#34;: 24, \\\u0026#34;intro\\\u0026#34;: \\\u0026#34;英文老师\\\u0026#34;, \\\u0026#34;gender\\\u0026#34;: \\\u0026#34;female\\\u0026#34;}\u0026#34;); user.setCreateTime(LocalDateTime.now()); user.setUpdateTime(user.getCreateTime()); return user; } 执行结果如下：\n可以看到速度非常慢。\n然后再试试MybatisPlus的批处理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Test void testSaveBatch() { // 准备10万条数据 List\u0026lt;User\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(1000); long b = System.currentTimeMillis(); for (int i = 1; i \u0026lt;= 100000; i++) { list.add(buildUser(i)); // 每1000条批量插入一次 if (i % 1000 == 0) { userService.saveBatch(list); list.clear(); } } long e = System.currentTimeMillis(); System.out.println(\u0026#34;耗时：\u0026#34; + (e - b)); } 执行最终耗时如下：\n可以看到使用了批处理以后，比逐条新增效率提高了10倍左右，性能还是不错的。\n不过，我们简单查看一下MybatisPlus源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Transactional(rollbackFor = Exception.class) @Override public boolean saveBatch(Collection\u0026lt;T\u0026gt; entityList, int batchSize) { String sqlStatement = getSqlStatement(SqlMethod.INSERT_ONE); return executeBatch(entityList, batchSize, (sqlSession, entity) -\u0026gt; sqlSession.insert(sqlStatement, entity)); } // ...SqlHelper public static \u0026lt;E\u0026gt; boolean executeBatch(Class\u0026lt;?\u0026gt; entityClass, Log log, Collection\u0026lt;E\u0026gt; list, int batchSize, BiConsumer\u0026lt;SqlSession, E\u0026gt; consumer) { Assert.isFalse(batchSize \u0026lt; 1, \u0026#34;batchSize must not be less than one\u0026#34;); return !CollectionUtils.isEmpty(list) \u0026amp;\u0026amp; executeBatch(entityClass, log, sqlSession -\u0026gt; { int size = list.size(); int idxLimit = Math.min(batchSize, size); int i = 1; for (E element : list) { consumer.accept(sqlSession, element); if (i == idxLimit) { sqlSession.flushStatements(); idxLimit = Math.min(idxLimit + batchSize, size); } i++; } }); } 可以发现其实MybatisPlus的批处理是基于PrepareStatement的预编译模式，然后批量提交，最终在数据库执行时还是会有多条insert语句，逐条插入数据。SQL类似这样：\n1 2 3 4 Preparing: INSERT INTO user ( username, password, phone, info, balance, create_time, update_time ) VALUES ( ?, ?, ?, ?, ?, ?, ? ) Parameters: user_1, 123, 18688190001, \u0026#34;\u0026#34;, 2000, 2023-07-01, 2023-07-01 Parameters: user_2, 123, 18688190002, \u0026#34;\u0026#34;, 2000, 2023-07-01, 2023-07-01 Parameters: user_3, 123, 18688190003, \u0026#34;\u0026#34;, 2000, 2023-07-01, 2023-07-01 而如果想要得到最佳性能，最好是将多条SQL合并为一条，像这样：\n1 2 3 4 5 6 INSERT INTO user ( username, password, phone, info, balance, create_time, update_time ) VALUES (user_1, 123, 18688190001, \u0026#34;\u0026#34;, 2000, 2023-07-01, 2023-07-01), (user_2, 123, 18688190002, \u0026#34;\u0026#34;, 2000, 2023-07-01, 2023-07-01), (user_3, 123, 18688190003, \u0026#34;\u0026#34;, 2000, 2023-07-01, 2023-07-01), (user_4, 123, 18688190004, \u0026#34;\u0026#34;, 2000, 2023-07-01, 2023-07-01); 该怎么做呢？\nMySQL的客户端连接参数中有这样的一个参数：rewriteBatchedStatements。顾名思义，就是重写批处理的statement语句。参考文档：\nhttps://dev.mysql.com/doc/connector-j/8.0/en/connector-j-connp-props-performance-extensions.html#cj-conn-prop_rewriteBatchedStatements\n这个参数的默认值是false，我们需要修改连接参数，将其配置为true\n修改项目中的application.yml文件，在jdbc的url后面添加参数\u0026amp;rewriteBatchedStatements=true:\n1 2 3 4 5 6 spring: datasource: url: jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true\u0026amp;characterEncoding=UTF-8\u0026amp;autoReconnect=true\u0026amp;serverTimezone=Asia/Shanghai\u0026amp;rewriteBatchedStatements=true driver-class-name: com.mysql.cj.jdbc.Driver username: root password: MySQL123 再次测试插入10万条数据，可以发现速度有非常明显的提升：\n在ClientPreparedStatement的executeBatchInternal中，有判断rewriteBatchedStatements值是否为true并重写SQL的功能：\n最终，SQL被重写了：\n3.扩展功能 3.1.代码生成 在使用MybatisPlus以后，基础的Mapper、Service、PO代码相对固定，重复编写也比较麻烦。因此MybatisPlus官方提供了代码生成器根据数据库表结构生成PO、Mapper、Service等相关代码。只不过代码生成器同样要编码使用，也很麻烦。\n这里推荐大家使用一款MybatisPlus的插件，它可以基于图形化界面完成MybatisPlus的代码生成，非常简单。\n3.1.1.安装插件 在Idea的plugins市场中搜索并安装MyBatisPlus插件：\n然后重启你的Idea即可使用。\n3.1.2.使用 刚好数据库中还有一张address表尚未生成对应的实体和mapper等基础代码。我们利用插件生成一下。 首先需要配置数据库地址，在Idea顶部菜单中，找到other，选择Config Database：\n在弹出的窗口中填写数据库连接的基本信息：\n点击OK保存。\n然后再次点击Idea顶部菜单中的other，然后选择Code Generator:\n在弹出的表单中填写信息：\n最终，代码自动生成到指定的位置了：\n3.2.静态工具 有的时候Service之间也会相互调用，为了避免出现循环依赖问题，MybatisPlus提供一个静态工具类：Db，其中的一些静态方法与IService中方法签名基本一致，也可以帮助我们实现CRUD功能：\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Test void testDbGet() { User user = Db.getById(1L, User.class); System.out.println(user); } @Test void testDbList() { // 利用Db实现复杂条件查询 List\u0026lt;User\u0026gt; list = Db.lambdaQuery(User.class) .like(User::getUsername, \u0026#34;o\u0026#34;) .ge(User::getBalance, 1000) .list(); list.forEach(System.out::println); } @Test void testDbUpdate() { Db.lambdaUpdate(User.class) .set(User::getBalance, 2000) .eq(User::getUsername, \u0026#34;Rose\u0026#34;); } 需求：改造根据id用户查询的接口，查询用户的同时返回用户收货地址列表\n首先，我们要添加一个收货地址的VO对象：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package com.itheima.mp.domain.vo; import io.swagger.annotations.ApiModel; import io.swagger.annotations.ApiModelProperty; import lombok.Data; @Data @ApiModel(description = \u0026#34;收货地址VO\u0026#34;) public class AddressVO{ @ApiModelProperty(\u0026#34;id\u0026#34;) private Long id; @ApiModelProperty(\u0026#34;用户ID\u0026#34;) private Long userId; @ApiModelProperty(\u0026#34;省\u0026#34;) private String province; @ApiModelProperty(\u0026#34;市\u0026#34;) private String city; @ApiModelProperty(\u0026#34;县/区\u0026#34;) private String town; @ApiModelProperty(\u0026#34;手机\u0026#34;) private String mobile; @ApiModelProperty(\u0026#34;详细地址\u0026#34;) private String street; @ApiModelProperty(\u0026#34;联系人\u0026#34;) private String contact; @ApiModelProperty(\u0026#34;是否是默认 1默认 0否\u0026#34;) private Boolean isDefault; @ApiModelProperty(\u0026#34;备注\u0026#34;) private String notes; } 然后，改造原来的UserVO，添加一个地址属性：\n接下来，修改UserController中根据id查询用户的业务接口：\n1 2 3 4 5 6 @GetMapping(\u0026#34;/{id}\u0026#34;) @ApiOperation(\u0026#34;根据id查询用户\u0026#34;) public UserVO queryUserById(@PathVariable(\u0026#34;id\u0026#34;) Long userId){ // 基于自定义service方法查询 return userService.queryUserAndAddressById(userId); } 由于查询业务复杂，所以要在service层来实现。首先在IUserService中定义方法：\n1 2 3 4 5 6 7 8 9 10 11 package com.itheima.mp.service; import com.baomidou.mybatisplus.extension.service.IService; import com.itheima.mp.domain.po.User; import com.itheima.mp.domain.vo.UserVO; public interface IUserService extends IService\u0026lt;User\u0026gt; { void deduct(Long id, Integer money); UserVO queryUserAndAddressById(Long userId); } 然后，在UserServiceImpl中实现该方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Override public UserVO queryUserAndAddressById(Long userId) { // 1.查询用户 User user = getById(userId); if (user == null) { return null; } // 2.查询收货地址 List\u0026lt;Address\u0026gt; addresses = Db.lambdaQuery(Address.class) .eq(Address::getUserId, userId) .list(); // 3.处理vo UserVO userVO = BeanUtil.copyProperties(user, UserVO.class); userVO.setAddresses(BeanUtil.copyToList(addresses, AddressVO.class)); return userVO; } 在查询地址时，我们采用了Db的静态方法，因此避免了注入AddressService，减少了循环依赖的风险。\n再来实现一个功能：\n根据id批量查询用户，并查询出用户对应的所有地址 **3.3.**逻辑删除 对于一些比较重要的数据，我们往往会采用逻辑删除的方案，即：\n在表中添加一个字段标记数据是否被删除 当删除数据时把标记置为true 查询时过滤掉标记为true的数据 一旦采用了逻辑删除，所有的查询和删除逻辑都要跟着变化，非常麻烦。\n为了解决这个问题，MybatisPlus就添加了对逻辑删除的支持。\n注意，只有MybatisPlus生成的SQL语句才支持自动的逻辑删除，自定义SQL需要自己手动处理逻辑删除。\n例如，我们给address表添加一个逻辑删除字段：\n1 alter table address add deleted bit default b\u0026#39;0\u0026#39; null comment \u0026#39;逻辑删除\u0026#39;; 然后给Address实体添加deleted字段：\n接下来，我们要在application.yml中配置逻辑删除字段：\n1 2 3 4 5 6 mybatis-plus: global-config: db-config: logic-delete-field: deleted # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2) logic-delete-value: 1 # 逻辑已删除值(默认为 1) logic-not-delete-value: 0 # 逻辑未删除值(默认为 0) 测试： 首先，我们执行一个删除操作：\n1 2 3 4 5 @Test void testDeleteByLogic() { // 删除方法与以前没有区别 addressService.removeById(59L); } 方法与普通删除一模一样，但是底层的SQL逻辑变了：\n查询一下试试：\n1 2 3 4 5 @Test void testQuery() { List\u0026lt;Address\u0026gt; list = addressService.list(); list.forEach(System.out::println); } 会发现id为59的确实没有查询出来，而且SQL中也对逻辑删除字段做了判断：\n综上， 开启了逻辑删除功能以后，我们就可以像普通删除一样做CRUD，基本不用考虑代码逻辑问题。还是非常方便的。\n注意： 逻辑删除本身也有自己的问题，比如：\n会导致数据库表垃圾数据越来越多，从而影响查询效率 SQL中全都需要对逻辑删除字段做判断，影响查询效率 因此，我不太推荐采用逻辑删除功能，如果数据不能删除，可以采用把数据迁移到其它表的办法。\n3.3.通用枚举 User类中有一个用户状态字段：\n像这种字段我们一般会定义一个枚举，做业务判断的时候就可以直接基于枚举做比较。但是我们数据库采用的是int类型，对应的PO也是Integer。因此业务操作时必须手动把枚举与Integer转换，非常麻烦。\n因此，MybatisPlus提供了一个处理枚举的类型转换器，可以帮我们把****枚举类型与数据库类型自动转换。\n3.3.1.定义枚举 我们定义一个用户状态的枚举：\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package com.itheima.mp.enums; import com.baomidou.mybatisplus.annotation.EnumValue; import lombok.Getter; @Getter public enum UserStatus { NORMAL(1, \u0026#34;正常\u0026#34;), FREEZE(2, \u0026#34;冻结\u0026#34;) ; private final int value; private final String desc; UserStatus(int value, String desc) { this.value = value; this.desc = desc; } } 然后把User类中的status字段改为UserStatus 类型：\n要让MybatisPlus处理枚举与数据库类型自动转换，我们必须告诉MybatisPlus，枚举中的哪个字段的值作为数据库值。 MybatisPlus提供了@EnumValue注解来标记枚举属性：\n3.3.2.配置枚举处理器 在application.yaml文件中添加配置：\n1 2 3 mybatis-plus: configuration: default-enum-type-handler: com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler 3.3.3.测试 1 2 3 4 5 @Test void testService() { List\u0026lt;User\u0026gt; list = userService.list(); list.forEach(System.out::println); } 最终，查询出的User类的status字段会是枚举类型：\n同时，为了使页面查询结果也是枚举格式，我们需要修改UserVO中的status属性：\n并且，在UserStatus枚举中通过@JsonValue注解标记JSON序列化时展示的字段：\n最后，在页面查询，结果如下：\n3.4.JSON类型处理器 数据库的user表中有一个info字段，是JSON类型：\n格式像这样：\n1 {\u0026#34;age\u0026#34;: 20, \u0026#34;intro\u0026#34;: \u0026#34;佛系青年\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;male\u0026#34;} 而目前User实体类中却是String类型：\n这样一来，我们要读取info中的属性时就非常不方便。如果要方便获取，info的类型最好是一个Map或者实体类。\n而一旦我们把info改为对象类型，就需要在写入数据库时手动转为String，再读取数据库时，手动转换为对象，这会非常麻烦。\n因此MybatisPlus提供了很多特殊类型字段的类型处理器，解决特殊字段类型与数据库类型转换的问题。例如处理JSON就可以使用JacksonTypeHandler处理器。\n接下来，我们就来看看这个处理器该如何使用。\n3.4.1.定义实体 首先，我们定义一个单独实体类来与info字段的属性匹配：\n代码如下：\n1 2 3 4 5 6 7 8 9 10 package com.itheima.mp.domain.po; import lombok.Data; @Data public class UserInfo { private Integer age; private String intro; private String gender; } 3.4.2.使用类型处理器 接下来，将User类的info字段修改为UserInfo类型，并声明类型处理器：\n同时，在User类上添加一个注解，声明自动映射：\n测试可以发现，所有数据都正确封装到UserInfo当中了：\n同时，为了让页面返回的结果也以对象格式返回，我们要修改UserVO中的info字段：\n此时，在页面查询结果如下：\n3.5.配置加密（选学） 目前我们配置文件中的很多参数都是明文，如果开发人员发生流动，很容易导致敏感信息的泄露。所以MybatisPlus支持配置文件的加密和解密功能。\n我们以数据库的用户名和密码为例。\n3.5.1.生成****秘钥 首先，我们利用AES工具生成一个随机秘钥，然后对用户名、密码加密：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package com.itheima.mp; import com.baomidou.mybatisplus.core.toolkit.AES; import org.junit.jupiter.api.Test; class MpDemoApplicationTests { @Test void contextLoads() { // 生成 16 位随机 AES 密钥 String randomKey = AES.generateRandomKey(); System.out.println(\u0026#34;randomKey = \u0026#34; + randomKey); // 利用密钥对用户名加密 String username = AES.encrypt(\u0026#34;root\u0026#34;, randomKey); System.out.println(\u0026#34;username = \u0026#34; + username); // 利用密钥对用户名加密 String password = AES.encrypt(\u0026#34;MySQL123\u0026#34;, randomKey); System.out.println(\u0026#34;password = \u0026#34; + password); } } 打印结果如下：\n1 2 3 randomKey = 6234633a66fb399f username = px2bAbnUfiY8K/IgsKvscg== password = FGvCSEaOuga3ulDAsxw68Q== 3.5.2.修改配置 修改application.yaml文件，把jdbc的用户名、密码修改为刚刚加密生成的密文：\n1 2 3 4 5 6 spring: datasource: url: jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true\u0026amp;characterEncoding=UTF-8\u0026amp;autoReconnect=true\u0026amp;serverTimezone=Asia/Shanghai\u0026amp;rewriteBatchedStatements=true driver-class-name: com.mysql.cj.jdbc.Driver username: mpw:QWWVnk1Oal3258x5rVhaeQ== # 密文要以 mpw:开头 password: mpw:EUFmeH3cNAzdRGdOQcabWg== # 密文要以 mpw:开头 3.5.3.测试 在启动项目的时候，需要把刚才生成的秘钥添加到启动参数中，像这样：\n\u0026ndash;mpw.key=6234633a66fb399f\n单元测试的时候不能添加启动参数，所以要在测试类的注解上配置：\n然后随意运行一个单元测试，可以发现数据库查询正常。\n4.插件功能 MybatisPlus提供了很多的插件功能，进一步拓展其功能。目前已有的插件有：\nPaginationInnerInterceptor：自动分页 TenantLineInnerInterceptor：多租户 DynamicTableNameInnerInterceptor：动态表名 OptimisticLockerInnerInterceptor：乐观锁 IllegalSQLInnerInterceptor：sql 性能规范 BlockAttackInnerInterceptor：防止全表更新与删除 注意： 使用多个分页插件的时候需要注意插件定义顺序，建议使用顺序如下：\n多租户,动态表名 分页,乐观锁 sql 性能规范,防止全表更新与删除 这里我们以分页插件为里来学习插件的用法。\n4.1.分页插件 在未引入分页插件的情况下，MybatisPlus是不支持分页功能的，IService和BaseMapper中的分页方法都无法正常起效。 所以，我们必须配置分页插件。\n4.1.1.配置分页插件 在项目中新建一个配置类：\n其代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package com.itheima.mp.config; import com.baomidou.mybatisplus.annotation.DbType; import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor; import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class MybatisConfig { @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { // 初始化核心插件 MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); // 添加分页插件 interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; } } 4.1.2.分页****API 编写一个分页查询的测试：\n1 2 3 4 5 6 7 8 9 10 11 12 @Test void testPageQuery() { // 1.分页查询，new Page()的两个参数分别是：页码、每页大小 Page\u0026lt;User\u0026gt; p = userService.page(new Page\u0026lt;\u0026gt;(2, 2)); // 2.总条数 System.out.println(\u0026#34;total = \u0026#34; + p.getTotal()); // 3.总页数 System.out.println(\u0026#34;pages = \u0026#34; + p.getPages()); // 4.数据 List\u0026lt;User\u0026gt; records = p.getRecords(); records.forEach(System.out::println); } 运行的SQL如下：\n这里用到了分页参数，Page，即可以支持分页参数，也可以支持排序参数。常见的API如下：\n1 2 3 4 5 6 7 int pageNo = 1, pageSize = 5; // 分页参数 Page\u0026lt;User\u0026gt; page = Page.of(pageNo, pageSize); // 排序参数, 通过OrderItem来指定 page.addOrder(new OrderItem(\u0026#34;balance\u0026#34;, false)); userService.page(page); 4.2.通用分页实体 现在要实现一个用户分页查询的接口，接口规范如下：\n参数 说明 请求方式 GET 请求路径 /users/page 请求参数 { \u0026quot;pageNo\u0026quot;: 1, \u0026quot;pageSize\u0026quot;: 5, \u0026quot;sortBy\u0026quot;: \u0026quot;balance\u0026quot;, \u0026quot;isAsc\u0026quot;: false, \u0026quot;name\u0026quot;: \u0026quot;o\u0026quot;, \u0026quot;status\u0026quot;: 1 } 返回值 { \u0026quot;total\u0026quot;: 100006, \u0026quot;pages\u0026quot;: 50003, \u0026quot;list\u0026quot;: [ { \u0026quot;id\u0026quot;: 1685100878975279298, \u0026quot;username\u0026quot;: \u0026quot;user_9****\u0026quot;, \u0026quot;info\u0026quot;: { \u0026quot;age\u0026quot;: 24, \u0026quot;intro\u0026quot;: \u0026quot;英文老师\u0026quot;, \u0026quot;gender\u0026quot;: \u0026quot;female\u0026quot; }, \u0026quot;status\u0026quot;: \u0026quot;正常\u0026quot;, \u0026quot;balance\u0026quot;: 2000 } ] } 特殊说明 如果排序字段为空，默认按照更新时间排序排序字段不为空，则按照排序字段排序 这里需要定义3个实体：\nUserQuery：分页查询条件的实体，包含分页、排序参数、过滤条件 PageDTO：分页结果实体，包含总条数、总页数、当前页数据 UserVO：用户页面视图实体 4.2.1.实体 由于UserQuery之前已经定义过了，并且其中已经包含了过滤条件，具体代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package com.itheima.mp.domain.query; import io.swagger.annotations.ApiModel; import io.swagger.annotations.ApiModelProperty; import lombok.Data; @Data @ApiModel(description = \u0026#34;用户查询条件实体\u0026#34;) public class UserQuery { @ApiModelProperty(\u0026#34;用户名关键字\u0026#34;) private String name; @ApiModelProperty(\u0026#34;用户状态：1-正常，2-冻结\u0026#34;) private Integer status; @ApiModelProperty(\u0026#34;余额最小值\u0026#34;) private Integer minBalance; @ApiModelProperty(\u0026#34;余额最大值\u0026#34;) private Integer maxBalance; } 其中缺少的仅仅是分页条件，而分页条件不仅仅用户分页查询需要，以后其它业务也都有分页查询的需求。因此建议将分页查询条件单独定义为一个PageQuery实体：\nPageQuery是前端提交的查询参数，一般包含四个属性：\npageNo：页码 pageSize：每页数据条数 sortBy：排序字段 isAsc：是否升序 1 2 3 4 5 6 7 8 9 10 11 12 @Data @ApiModel(description = \u0026#34;分页查询实体\u0026#34;) public class PageQuery { @ApiModelProperty(\u0026#34;页码\u0026#34;) private Long pageNo; @ApiModelProperty(\u0026#34;页码\u0026#34;) private Long pageSize; @ApiModelProperty(\u0026#34;排序字段\u0026#34;) private String sortBy; @ApiModelProperty(\u0026#34;是否升序\u0026#34;) private Boolean isAsc; } 然后，让我们的UserQuery继承这个实体：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package com.itheima.mp.domain.query; import io.swagger.annotations.ApiModel; import io.swagger.annotations.ApiModelProperty; import lombok.Data; import lombok.EqualsAndHashCode; @EqualsAndHashCode(callSuper = true) @Data @ApiModel(description = \u0026#34;用户查询条件实体\u0026#34;) public class UserQuery extends PageQuery { @ApiModelProperty(\u0026#34;用户名关键字\u0026#34;) private String name; @ApiModelProperty(\u0026#34;用户状态：1-正常，2-冻结\u0026#34;) private Integer status; @ApiModelProperty(\u0026#34;余额最小值\u0026#34;) private Integer minBalance; @ApiModelProperty(\u0026#34;余额最大值\u0026#34;) private Integer maxBalance; } 返回值的用户实体沿用之前定一个UserVO实体：\n最后，则是分页实体PageDTO:\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package com.itheima.mp.domain.dto; import io.swagger.annotations.ApiModel; import io.swagger.annotations.ApiModelProperty; import lombok.Data; import java.util.List; @Data @ApiModel(description = \u0026#34;分页结果\u0026#34;) public class PageDTO\u0026lt;T\u0026gt; { @ApiModelProperty(\u0026#34;总条数\u0026#34;) private Long total; @ApiModelProperty(\u0026#34;总页数\u0026#34;) private Long pages; @ApiModelProperty(\u0026#34;集合\u0026#34;) private List\u0026lt;T\u0026gt; list; } 4.2.2.开发接口 我们在UserController中定义分页查询用户的接口：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package com.itheima.mp.controller; import com.itheima.mp.domain.dto.PageDTO; import com.itheima.mp.domain.query.PageQuery; import com.itheima.mp.domain.vo.UserVO; import com.itheima.mp.service.UserService; import lombok.RequiredArgsConstructor; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\u0026#34;users\u0026#34;) @RequiredArgsConstructor public class UserController { private final UserService userService; @GetMapping(\u0026#34;/page\u0026#34;) public PageDTO\u0026lt;UserVO\u0026gt; queryUsersPage(UserQuery query){ return userService.queryUsersPage(query); } // 。。。 略 } 然后在IUserService中创建queryUsersPage方法：\n1 PageDTO\u0026lt;UserVO\u0026gt; queryUsersPage(PageQuery query); 接下来，在UserServiceImpl中实现该方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Override public PageDTO\u0026lt;UserVO\u0026gt; queryUsersPage(PageQuery query) { // 1.构建条件 // 1.1.分页条件 Page\u0026lt;User\u0026gt; page = Page.of(query.getPageNo(), query.getPageSize()); // 1.2.排序条件 if (query.getSortBy() != null) { page.addOrder(new OrderItem(query.getSortBy(), query.getIsAsc())); }else{ // 默认按照更新时间排序 page.addOrder(new OrderItem(\u0026#34;update_time\u0026#34;, false)); } // 2.查询 page(page); // 3.数据非空校验 List\u0026lt;User\u0026gt; records = page.getRecords(); if (records == null || records.size() \u0026lt;= 0) { // 无数据，返回空结果 return new PageDTO\u0026lt;\u0026gt;(page.getTotal(), page.getPages(), Collections.emptyList()); } // 4.有数据，转换 List\u0026lt;UserVO\u0026gt; list = BeanUtil.copyToList(records, UserVO.class); // 5.封装返回 return new PageDTO\u0026lt;UserVO\u0026gt;(page.getTotal(), page.getPages(), list); } 启动项目，在页面查看：\n4.2.3.改造PageQuery实体 在刚才的代码中，从PageQuery到MybatisPlus的Page之间转换的过程还是比较麻烦的。\n我们完全可以在PageQuery这个实体中定义一个工具方法，简化开发。 像这样：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package com.itheima.mp.domain.query; import com.baomidou.mybatisplus.core.metadata.OrderItem; import com.baomidou.mybatisplus.extension.plugins.pagination.Page; import lombok.Data; @Data public class PageQuery { private Integer pageNo; private Integer pageSize; private String sortBy; private Boolean isAsc; public \u0026lt;T\u0026gt; Page\u0026lt;T\u0026gt; toMpPage(OrderItem ... orders){ // 1.分页条件 Page\u0026lt;T\u0026gt; p = Page.of(pageNo, pageSize); // 2.排序条件 // 2.1.先看前端有没有传排序字段 if (sortBy != null) { p.addOrder(new OrderItem(sortBy, isAsc)); return p; } // 2.2.再看有没有手动指定排序字段 if(orders != null){ p.addOrder(orders); } return p; } public \u0026lt;T\u0026gt; Page\u0026lt;T\u0026gt; toMpPage(String defaultSortBy, boolean isAsc){ return this.toMpPage(new OrderItem(defaultSortBy, isAsc)); } public \u0026lt;T\u0026gt; Page\u0026lt;T\u0026gt; toMpPageDefaultSortByCreateTimeDesc() { return toMpPage(\u0026#34;create_time\u0026#34;, false); } public \u0026lt;T\u0026gt; Page\u0026lt;T\u0026gt; toMpPageDefaultSortByUpdateTimeDesc() { return toMpPage(\u0026#34;update_time\u0026#34;, false); } } 这样我们在开发也时就可以省去对从PageQuery到Page的的转换：\n1 2 // 1.构建条件 Page\u0026lt;User\u0026gt; page = query.toMpPageDefaultSortByCreateTimeDesc(); 4.2.4.改造PageDTO实体 在查询出分页结果后，数据的非空校验，数据的vo转换都是模板代码，编写起来很麻烦。\n我们完全可以将其封装到PageDTO的工具方法中，简化整个过程：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 package com.itheima.mp.domain.dto; import cn.hutool.core.bean.BeanUtil; import com.baomidou.mybatisplus.extension.plugins.pagination.Page; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import java.util.Collections; import java.util.List; import java.util.function.Function; import java.util.stream.Collectors; @Data @NoArgsConstructor @AllArgsConstructor public class PageDTO\u0026lt;V\u0026gt; { private Long total; private Long pages; private List\u0026lt;V\u0026gt; list; /** * 返回空分页结果 * @param p MybatisPlus的分页结果 * @param \u0026lt;V\u0026gt; 目标VO类型 * @param \u0026lt;P\u0026gt; 原始PO类型 * @return VO的分页对象 */ public static \u0026lt;V, P\u0026gt; PageDTO\u0026lt;V\u0026gt; empty(Page\u0026lt;P\u0026gt; p){ return new PageDTO\u0026lt;\u0026gt;(p.getTotal(), p.getPages(), Collections.emptyList()); } /** * 将MybatisPlus分页结果转为 VO分页结果 * @param p MybatisPlus的分页结果 * @param voClass 目标VO类型的字节码 * @param \u0026lt;V\u0026gt; 目标VO类型 * @param \u0026lt;P\u0026gt; 原始PO类型 * @return VO的分页对象 */ public static \u0026lt;V, P\u0026gt; PageDTO\u0026lt;V\u0026gt; of(Page\u0026lt;P\u0026gt; p, Class\u0026lt;V\u0026gt; voClass) { // 1.非空校验 List\u0026lt;P\u0026gt; records = p.getRecords(); if (records == null || records.size() \u0026lt;= 0) { // 无数据，返回空结果 return empty(p); } // 2.数据转换 List\u0026lt;V\u0026gt; vos = BeanUtil.copyToList(records, voClass); // 3.封装返回 return new PageDTO\u0026lt;\u0026gt;(p.getTotal(), p.getPages(), vos); } /** * 将MybatisPlus分页结果转为 VO分页结果，允许用户自定义PO到VO的转换方式 * @param p MybatisPlus的分页结果 * @param convertor PO到VO的转换函数 * @param \u0026lt;V\u0026gt; 目标VO类型 * @param \u0026lt;P\u0026gt; 原始PO类型 * @return VO的分页对象 */ public static \u0026lt;V, P\u0026gt; PageDTO\u0026lt;V\u0026gt; of(Page\u0026lt;P\u0026gt; p, Function\u0026lt;P, V\u0026gt; convertor) { // 1.非空校验 List\u0026lt;P\u0026gt; records = p.getRecords(); if (records == null || records.size() \u0026lt;= 0) { // 无数据，返回空结果 return empty(p); } // 2.数据转换 List\u0026lt;V\u0026gt; vos = records.stream().map(convertor).collect(Collectors.toList()); // 3.封装返回 return new PageDTO\u0026lt;\u0026gt;(p.getTotal(), p.getPages(), vos); } } 最终，业务层的代码可以简化为：\n1 2 3 4 5 6 7 8 9 @Override public PageDTO\u0026lt;UserVO\u0026gt; queryUserByPage(PageQuery query) { // 1.构建条件 Page\u0026lt;User\u0026gt; page = query.toMpPageDefaultSortByCreateTimeDesc(); // 2.查询 page(page); // 3.封装返回 return PageDTO.of(page, UserVO.class); } 如果是希望自定义PO到VO的转换过程，可以这样做：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Override public PageDTO\u0026lt;UserVO\u0026gt; queryUserByPage(PageQuery query) { // 1.构建条件 Page\u0026lt;User\u0026gt; page = query.toMpPageDefaultSortByCreateTimeDesc(); // 2.查询 page(page); // 3.封装返回 return PageDTO.of(page, user -\u0026gt; { // 拷贝属性到VO UserVO vo = BeanUtil.copyProperties(user, UserVO.class); // 用户名脱敏 String username = vo.getUsername(); vo.setUsername(username.substring(0, username.length() - 2) + \u0026#34;**\u0026#34;); return vo; }); } 最终查询的结果如下：\n","date":"2024-10-11T00:00:00Z","image":"https://yanbin582.github.io/p/mybatisplus/Snipaste_2025-03-22_13-53-41_hu13533275287591799937.png","permalink":"https://yanbin582.github.io/p/mybatisplus/","title":"MybatisPlus"},{"content":"Markdown 基本语法 Markdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia、简书等。\n在线体验一下 Markdown在线编辑器 (opens new window)。\n千万不要被「标记」、「语言」吓到，Markdown的语法十分简单，常用的标记符号不超过十个，用于日常写作记录绰绰有余，不到半小时就能完全掌握。\n就是这十个不到的标记符号，却能让人优雅地沉浸式记录，专注内容而不是纠结排版，达到「心中无尘，码字入神」的境界。\nMarkdown 标题语法 要创建标题，请在单词或短语前面添加井号 (#) 。# 的数量代表了标题的级别。例如，添加三个 # 表示创建一个三级标题 (\u0026lt;h3\u0026gt;) (例如：### My Header)。\nMarkdown语法 HTML 预览效果 # Heading level 1 \u0026lt;h1\u0026gt;Heading level 1\u0026lt;/h1\u0026gt; Heading level 1 ## Heading level 2 \u0026lt;h2\u0026gt;Heading level 2\u0026lt;/h2\u0026gt; Heading level 2 ### Heading level 3 \u0026lt;h3\u0026gt;Heading level 3\u0026lt;/h3\u0026gt; Heading level 3 #### Heading level 4 \u0026lt;h4\u0026gt;Heading level 4\u0026lt;/h4\u0026gt; Heading level 4 ##### Heading level 5 \u0026lt;h5\u0026gt;Heading level 5\u0026lt;/h5\u0026gt; Heading level 5 ###### Heading level 6 \u0026lt;h6\u0026gt;Heading level 6\u0026lt;/h6\u0026gt; Heading level 6 #可选语法 还可以在文本下方添加任意数量的 == 号来标识一级标题，或者 \u0026ndash; 号来标识二级标题。\nMarkdown语法 HTML 预览效果 Heading level 1=============== \u0026lt;h1\u0026gt;Heading level 1\u0026lt;/h1\u0026gt; Heading level 1 Heading level 2--------------- \u0026lt;h2\u0026gt;Heading level 2\u0026lt;/h2\u0026gt; Heading level 2 #最佳实践 不同的 Markdown 应用程序处理 # 和标题之间的空格方式并不一致。为了兼容考虑，请用一个空格在 # 和标题之间进行分隔。\n✅ Do this ❌ Don\u0026rsquo;t do this # Here's a Heading #Here's a Heading Markdown 段落 要创建段落，请使用空白行将一行或多行文本进行分隔。\nMarkdown语法 HTML 预览效果 I really like using Markdown.I think I'll use it to format all of my documents from now on. \u0026lt;p\u0026gt;I really like using Markdown.\u0026lt;/p\u0026gt;\u0026lt;p\u0026gt;I think I'll use it to format all of my documents from now on.\u0026lt;/p\u0026gt; I really like using Markdown.I think I\u0026rsquo;ll use it to format all of my documents from now on. #段落（Paragraph）用法的最佳实 不要用空格（spaces）或制表符（ tabs）缩进段落。\n✅ Do this ❌ Don\u0026rsquo;t do this Don't put tabs or spaces in front of your paragraphs.Keep lines left-aligned like this. This can result in unexpected formatting problems. Don't add tabs or spaces in front of paragraphs. Markdown 换行语法 在一行的末尾添加两个或多个空格，然后按回车键,即可创建一个换行(\u0026lt;br\u0026gt;)。\nMarkdown语法 HTML 预览效果 This is the first line. And this is the second line. \u0026lt;p\u0026gt;This is the first line.\u0026lt;br\u0026gt;And this is the second line.\u0026lt;/p\u0026gt; This is the first line. And this is the second line. #换行（Line Break）用法的最佳实践 几乎每个 Markdown 应用程序都支持两个或多个空格进行换行，称为 结尾空格（trailing whitespace) 的方式，但这是有争议的，因为很难在编辑器中直接看到空格，并且很多人在每个句子后面都会有意或无意地添加两个空格。由于这个原因，你可能要使用除结尾空格以外的其它方式来换行。幸运的是，几乎每个 Markdown 应用程序都支持另一种换行方式：HTML 的 \u0026lt;br\u0026gt; 标签。\n为了兼容性，请在行尾添加“结尾空格”或 HTML 的 \u0026lt;br\u0026gt; 标签来实现换行。\n还有两种其他方式我并不推荐使用。CommonMark 和其它几种轻量级标记语言支持在行尾添加反斜杠 (\\) 的方式实现换行，但是并非所有 Markdown 应用程序都支持此种方式，因此从兼容性的角度来看，不推荐使用。并且至少有两种轻量级标记语言支持无须在行尾添加任何内容，只须键入回车键（return）即可实现换行。\n✅ Do this ❌ Don\u0026rsquo;t do this First line with two spaces after. And the next line.First line with the HTML tag after.\u0026lt;br\u0026gt;And the next line. First line with a backslash after.\\And the next line.First line with nothing after.And the next line. Markdown 强调语法 通过将文本设置为粗体或斜体来强调其重要性。\n#粗体（Bold） 要加粗文本，请在单词或短语的前后各添加两个星号（asterisks）或下划线（underscores）。如需加粗一个单词或短语的中间部分用以表示强调的话，请在要加粗部分的两侧各添加两个星号（asterisks）。\nMarkdown语法 HTML 预览效果 I just love **bold text**. I just love \u0026lt;strong\u0026gt;bold text\u0026lt;/strong\u0026gt;. I just love bold text. I just love __bold text__. I just love \u0026lt;strong\u0026gt;bold text\u0026lt;/strong\u0026gt;. I just love bold text. Love**is**bold Love\u0026lt;strong\u0026gt;is\u0026lt;/strong\u0026gt;bold Loveisbold #粗体（Bold）用法最佳实践 Markdown 应用程序在如何处理单词或短语中间的下划线上并不一致。为兼容考虑，在单词或短语中间部分加粗的话，请使用星号（asterisks）。\n✅ Do this ❌ Don\u0026rsquo;t do this Love**is**bold Love__is__bold #斜体（Italic） 要用斜体显示文本，请在单词或短语前后添加一个星号（asterisk）或下划线（underscore）。要斜体突出单词的中间部分，请在字母前后各添加一个星号，中间不要带空格。\nMarkdown语法 HTML 预览效果 Italicized text is the *cat's meow*. Italicized text is the \u0026lt;em\u0026gt;cat's meow\u0026lt;/em\u0026gt;. Italicized text is the cat’s meow. Italicized text is the _cat's meow_. Italicized text is the \u0026lt;em\u0026gt;cat's meow\u0026lt;/em\u0026gt;. Italicized text is the cat’s meow. A*cat*meow A\u0026lt;em\u0026gt;cat\u0026lt;/em\u0026gt;meow Acatmeow #斜体（Italic）用法的最佳实践 要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线。要加粗并用斜体显示单词或短语的中间部分，请在要突出显示的部分前后各添加三个星号，中间不要带空格。\n✅ Do this ❌ Don\u0026rsquo;t do this A*cat*meow A_cat_meow #粗体（Bold）和斜体（Italic） 要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线。要加粗并用斜体显示单词或短语的中间部分，请在要突出显示的部分前后各添加三个星号，中间不要带空格。\nMarkdown语法 HTML 预览效果 This text is ***really important***. This text is \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;really important\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;. This text is *really important*. This text is ___really important___. This text is \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;really important\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;. This text is *really important*. This text is __*really important*__. This text is \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;really important\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;. This text is *really important*. This text is **_really important_**. This text is \u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;really important\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;. This text is *really important*. This is really***very***important text. This is really\u0026lt;strong\u0026gt;\u0026lt;em\u0026gt;very\u0026lt;/em\u0026gt;\u0026lt;/strong\u0026gt;important text. This is really***very***important text. #粗体（Bold）和斜体（Italic）用法的最佳实践 Markdown 应用程序在处理单词或短语中间添加的下划线上并不一致。为了实现兼容性，请使用星号将单词或短语的中间部分加粗并以斜体显示，以示重要。\n✅ Do this ❌ Don\u0026rsquo;t do this This is really***very***important text. This is really___very___important text. Markdown 引用语法 要创建块引用，请在段落前添加一个 \u0026gt; 符号。\n1 \u0026gt; Dorothy followed her through many of the beautiful rooms in her castle. 渲染效果如下所示：\nDorothy followed her through many of the beautiful rooms in her castle.\n#多个段落的块引用 块引用可以包含多个段落。为段落之间的空白行添加一个 \u0026gt; 符号。\n1 2 3 \u0026gt; Dorothy followed her through many of the beautiful rooms in her castle. \u0026gt; \u0026gt; The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood. 渲染效果如下：\nDorothy followed her through many of the beautiful rooms in her castle.\nThe Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.\n#嵌套块引用 块引用可以嵌套。在要嵌套的段落前添加一个 \u0026gt;\u0026gt; 符号。\n1 2 3 \u0026gt; Dorothy followed her through many of the beautiful rooms in her castle. \u0026gt; \u0026gt;\u0026gt; The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood. 渲染效果如下：\nDorothy followed her through many of the beautiful rooms in her castle.\nThe Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.\n#带有其它元素的块引用 块引用可以包含其他 Markdown 格式的元素。并非所有元素都可以使用，你需要进行实验以查看哪些元素有效。\n1 2 3 4 5 6 \u0026gt; #### The quarterly results look great! \u0026gt; \u0026gt; - Revenue was off the chart. \u0026gt; - Profits were higher than ever. \u0026gt; \u0026gt; *Everything* is going according to **plan**. 渲染效果如下：\nThe quarterly results look great! Revenue was off the chart. Profits were higher than ever. Everything is going according to plan.\nMarkdown 列表语法 可以将多个条目组织成有序或无序列表。\n#有序列表 要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。\nMarkdown语法 HTML 预览效果 1. First item2. Second item3. Third item4. Fourth item \u0026lt;ol\u0026gt;\u0026lt;li\u0026gt;First item\u0026lt;/li\u0026gt;\u0026lt;li\u0026gt;Second item\u0026lt;/li\u0026gt;\u0026lt;li\u0026gt;Third item\u0026lt;/li\u0026gt;\u0026lt;li\u0026gt;Fourth item\u0026lt;/li\u0026gt;\u0026lt;/ol\u0026gt; First itemSecond itemThird itemFourth item 1. First item1. Second item1. Third item1. Fourth item \u0026lt;ol\u0026gt;\u0026lt;li\u0026gt;First item\u0026lt;/li\u0026gt;\u0026lt;li\u0026gt;Second item\u0026lt;/li\u0026gt;\u0026lt;li\u0026gt;Third item\u0026lt;/li\u0026gt;\u0026lt;li\u0026gt;Fourth item\u0026lt;/li\u0026gt;\u0026lt;/ol\u0026gt; First itemSecond itemThird itemFourth item 1. First item8. Second item3. Third item5. Fourth item \u0026lt;ol\u0026gt;\u0026lt;li\u0026gt;First item\u0026lt;/li\u0026gt;\u0026lt;li\u0026gt;Second item\u0026lt;/li\u0026gt;\u0026lt;li\u0026gt;Third item\u0026lt;/li\u0026gt;\u0026lt;li\u0026gt;Fourth item\u0026lt;/li\u0026gt;\u0026lt;/ol\u0026gt; First itemSecond itemThird itemFourth item 1. First item2. Second item3. Third item 1. Indented item 2. Indented item4. Fourth item \u0026lt;ol\u0026gt;\u0026lt;li\u0026gt;First item\u0026lt;/li\u0026gt;\u0026lt;li\u0026gt;Second item\u0026lt;/li\u0026gt;\u0026lt;li\u0026gt;Third item\u0026lt;ol\u0026gt;\u0026lt;li\u0026gt;Indented item\u0026lt;/li\u0026gt;\u0026lt;li\u0026gt;Indented item\u0026lt;/li\u0026gt;\u0026lt;/ol\u0026gt;\u0026lt;/li\u0026gt;\u0026lt;li\u0026gt;Fourth item\u0026lt;/li\u0026gt;\u0026lt;/ol\u0026gt; First itemSecond itemThird itemIndented itemIndented itemFourth item #有序列表最佳实践 CommonMark and a few other lightweight markup languages let you use a parenthesis ()) as a delimiter (e.g., 1) First item), but not all Markdown applications support this, so it isn’t a great option from a compatibility perspective. For compatibility, use periods only.\n✅ Do this ❌ Don\u0026rsquo;t do this 1. First item2. Second item 1) First item2) Second item #无序列表 要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。\nMarkdown语法 HTML 预览效果 - First item- Second item- Third item- Fourth item \u0026lt;ul\u0026gt;\u0026lt;li\u0026gt;First item\u0026lt;/li\u0026gt;\u0026lt;li\u0026gt;Second item\u0026lt;/li\u0026gt;\u0026lt;li\u0026gt;Third item\u0026lt;/li\u0026gt;\u0026lt;li\u0026gt;Fourth item\u0026lt;/li\u0026gt;\u0026lt;/ul\u0026gt; First itemSecond itemThird itemFourth item * First item* Second item* Third item* Fourth item \u0026lt;ul\u0026gt;\u0026lt;li\u0026gt;First item\u0026lt;/li\u0026gt;\u0026lt;li\u0026gt;Second item\u0026lt;/li\u0026gt;\u0026lt;li\u0026gt;Third item\u0026lt;/li\u0026gt;\u0026lt;li\u0026gt;Fourth item\u0026lt;/li\u0026gt;\u0026lt;/ul\u0026gt; First itemSecond itemThird itemFourth item + First item+ Second item+ Third item+ Fourth item \u0026lt;ul\u0026gt;\u0026lt;li\u0026gt;First item\u0026lt;/li\u0026gt;\u0026lt;li\u0026gt;Second item\u0026lt;/li\u0026gt;\u0026lt;li\u0026gt;Third item\u0026lt;/li\u0026gt;\u0026lt;li\u0026gt;Fourth item\u0026lt;/li\u0026gt;\u0026lt;/ul\u0026gt; First itemSecond itemThird itemFourth item - First item- Second item- Third item - Indented item - Indented item- Fourth item \u0026lt;ul\u0026gt;\u0026lt;li\u0026gt;First item\u0026lt;/li\u0026gt;\u0026lt;li\u0026gt;Second item\u0026lt;/li\u0026gt;\u0026lt;li\u0026gt;Third item\u0026lt;ul\u0026gt;\u0026lt;li\u0026gt;Indented item\u0026lt;/li\u0026gt;\u0026lt;li\u0026gt;Indented item\u0026lt;/li\u0026gt;\u0026lt;/ul\u0026gt;\u0026lt;/li\u0026gt;\u0026lt;li\u0026gt;Fourth item\u0026lt;/li\u0026gt;\u0026lt;/ul\u0026gt; First itemSecond itemThird itemIndented itemIndented itemFourth item #无序列表最佳实践 Markdown applications don’t agree on how to handle different delimiters in the same list. For compatibility, don\u0026rsquo;t mix and match delimiters in the same list — pick one and stick with it.\n✅ Do this ❌ Don\u0026rsquo;t do this - First item- Second item- Third item- Fourth item + First item* Second item- Third item+ Fourth item #在列表中嵌套其他元素 要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格或一个制表符，如下例所示：\n#段落 1 2 3 4 5 6 * This is the first list item. * Here\u0026#39;s the second list item. I need to add another paragraph below the second list item. * And here\u0026#39;s the third list item. 渲染效果如下：\nThis is the first list item.\nHere\u0026rsquo;s the second list item.\nI need to add another paragraph below the second list item.\nAnd here\u0026rsquo;s the third list item.\n#引用块 1 2 3 4 5 6 * This is the first list item. * Here\u0026#39;s the second list item. \u0026gt; A blockquote would look great below the second list item. * And here\u0026#39;s the third list item. 渲染效果如下：\nThis is the first list item.\nHere\u0026rsquo;s the second list item.\nA blockquote would look great below the second list item.\nAnd here\u0026rsquo;s the third list item.\n#代码块 代码块通常采用四个空格或一个制表符缩进。当它们被放在列表中时，请将它们缩进八个空格或两个制表符。\n1 2 3 4 5 6 7 8 9 1. Open the file. 2. Find the following code block on line 21: \u0026amp;lt;html\u0026gt; \u0026amp;lt;head\u0026gt; \u0026amp;lt;title\u0026gt;Test\u0026amp;lt;/title\u0026gt; \u0026amp;lt;/head\u0026gt; 3. Update the title to match the name of your website. 渲染效果如下：\nOpen the file.\nFind the following code block on line 21:\n1 2 3 4 \u0026amp;lt;html\u0026gt; \u0026amp;lt;head\u0026gt; \u0026amp;lt;title\u0026gt;Test\u0026amp;lt;/title\u0026gt; \u0026amp;lt;/head\u0026gt; Update the title to match the name of your website.\n#图片 1 2 3 4 5 6 1. Open the file containing the Linux mascot. 2. Marvel at its beauty. ![Tux, the Linux mascot](/assets/images/tux.png) 3. Close the file. 渲染效果如下：\nOpen the file containing the Linux mascot.\nMarvel at its beauty.\nClose the file.\n#列表 You can nest an unordered list in an ordered list, or vice versa.\n1 2 3 4 5 6 1. First item 2. Second item 3. Third item - Indented item - Indented item 4. Fourth item 渲染效果如下：\nFirst item Second item Third item Indented item Indented item Fourth item Markdown 代码语法 要将单词或短语表示为代码，请将其包裹在反引号 (```) 中。\nMarkdown语法 HTML 预览效果 At the command prompt, type nano. At the command prompt, type \u0026lt;code\u0026gt;nano\u0026lt;/code\u0026gt;. At the command prompt, type nano. #转义反引号 如果你要表示为代码的单词或短语中包含一个或多个反引号，则可以通过将单词或短语包裹在双反引号(````)中。\nMarkdown语法 HTML 预览效果 Use `code` in your Markdown file. \u0026lt;code\u0026gt;Use code in your Markdown file.\u0026lt;/code\u0026gt; Use code in your Markdown file. #代码块 要创建代码块，请将代码块的每一行缩进至少四个空格或一个制表符。\n1 2 3 4 \u0026amp;lt;html\u0026gt; \u0026amp;lt;head\u0026gt; \u0026amp;lt;/head\u0026gt; \u0026amp;lt;/html\u0026gt; 渲染效果如下：\n1 2 3 4 \u0026amp;lt;html\u0026gt; \u0026amp;lt;head\u0026gt; \u0026amp;lt;/head\u0026gt; \u0026amp;lt;/html\u0026gt; Note: 要创建不用缩进的代码块，请使用 围栏式代码块（fenced code blocks）.\nMarkdown 分隔线语法 要创建分隔线，请在单独一行上使用三个或多个星号 (***)、破折号 (---) 或下划线 (___) ，并且不能包含其他内容。\n1 2 3 4 5 *** --- _________________ 以上三个分隔线的渲染效果看起来都一样：\n#分隔线（Horizontal Rule）用法最佳实践 为了兼容性，请在分隔线的前后均添加空白行。\n✅ Do this ❌ Don\u0026rsquo;t do this Try to put a blank line before...---...and after a horizontal rule. Without blank lines, this would be a heading.---Don't do this! Markdown 链接语法 链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。\n超链接Markdown语法代码：[超链接显示名](超链接地址 \u0026quot;超链接title\u0026quot;)\n对应的HTML代码：\u0026lt;a href=\u0026quot;超链接地址\u0026quot; title=\u0026quot;超链接title\u0026quot;\u0026gt;超链接显示名\u0026lt;/a\u0026gt;\n1 这是一个链接 [Markdown语法](https://markdown.com.cn)。 渲染效果如下：\n这是一个链接 Markdown语法 (opens new window)。\n#给链接增加 Title 链接title是当鼠标悬停在链接上时会出现的文字，这个title是可选的，它放在圆括号中链接地址后面，跟链接地址之间以空格分隔。\n1 这是一个链接 [Markdown语法](https://markdown.com.cn \u0026#34;最好的markdown教程\u0026#34;)。 渲染效果如下：\n这是一个链接 Markdown语法 (opens new window)。\n#网址和Email地址 使用尖括号可以很方便地把URL或者email地址变成可点击的链接。\n1 2 \u0026lt;https://markdown.com.cn\u0026gt; \u0026lt;fake@example.com\u0026gt; 渲染效果如下：\nhttps://markdown.com.cn(opens new window) fake@example.com\n#带格式化的链接 强调 链接, 在链接语法前后增加星号。 要将链接表示为代码，请在方括号中添加反引号。\n1 2 3 I love supporting the **[EFF](https://eff.org)**. This is the *[Markdown Guide](https://www.markdownguide.org)*. See the section on [`code`](#code). 渲染效果如下：\nI love supporting the EFF (opens new window). This is the Markdown Guide (opens new window). See the section on code.\n#引用类型链接 引用样式链接是一种特殊的链接，它使URL在Markdown中更易于显示和阅读。参考样式链接分为两部分：与文本保持内联的部分以及存储在文件中其他位置的部分，以使文本易于阅读。\n#链接的第一部分格式 引用类型的链接的第一部分使用两组括号进行格式设置。第一组方括号包围应显示为链接的文本。第二组括号显示了一个标签，该标签用于指向您存储在文档其他位置的链接。\n尽管不是必需的，可以在第一组和第二组括号之间包含一个空格。第二组括号中的标签不区分大小写，可以包含字母，数字，空格或标点符号。\n以下示例格式对于链接的第一部分效果相同：\n[hobbit-hole][1] [hobbit-hole] [1] #链接的第二部分格式 引用类型链接的第二部分使用以下属性设置格式：\n放在括号中的标签，其后紧跟一个冒号和至少一个空格（例如[label]:）。 链接的URL，可以选择将其括在尖括号中。 链接的可选标题，可以将其括在双引号，单引号或括号中。 以下示例格式对于链接的第二部分效果相同：\n[1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle [1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle \u0026quot;Hobbit lifestyles\u0026quot; [1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle 'Hobbit lifestyles' [1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle (Hobbit lifestyles) [1]: \u0026lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle\u0026gt; \u0026quot;Hobbit lifestyles\u0026quot; [1]: \u0026lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle\u0026gt; 'Hobbit lifestyles' [1]: \u0026lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle\u0026gt; (Hobbit lifestyles) 可以将链接的第二部分放在Markdown文档中的任何位置。有些人将它们放在出现的段落之后，有些人则将它们放在文档的末尾（例如尾注或脚注）。\n#链接最佳实践 不同的 Markdown 应用程序处理URL中间的空格方式不一样。为了兼容性，请尽量使用%20代替空格。\n✅ Do this ❌ Don\u0026rsquo;t do this [link](https://www.example.com/my%20great%20page) [link](https://www.example.com/my great page) Markdown 图片语法 要添加图像，请使用感叹号 (!), 然后在方括号增加替代文本，图片链接放在圆括号里，括号里的链接后可以增加一个可选的图片标题文本。\n插入图片Markdown语法代码：![图片alt](图片链接 \u0026quot;图片title\u0026quot;)。\n对应的HTML代码：\u0026lt;img src=\u0026quot;图片链接\u0026quot; alt=\u0026quot;图片alt\u0026quot; title=\u0026quot;图片title\u0026quot;\u0026gt;\n1 ![这是图片](/assets/img/philly-magic-garden.jpg \u0026#34;Magic Gardens\u0026#34;) 渲染效果如下：\n#链接图片 给图片增加链接，请将图像的Markdown 括在方括号中，然后将链接添加在圆括号中。\n1 [![沙漠中的岩石图片](/assets/img/shiprock.jpg \u0026#34;Shiprock\u0026#34;)](https://markdown.com.cn) 渲染效果如下：\nMarkdown 转义字符语法 要显示原本用于格式化 Markdown 文档的字符，请在字符前面添加反斜杠字符 \\ 。\n1 \\* Without the backslash, this would be a bullet in an unordered list. 渲染效果如下：\n* Without the backslash, this would be a bullet in an unordered list.\n#可做转义的字符 以下列出的字符都可以通过使用反斜杠字符从而达到转义目的。\nCharacter Name \\ backslash ` backtick (see also escaping backticks in code) * asterisk _ underscore { } curly braces [ ] brackets ( ) parentheses # pound sign + plus sign - minus sign (hyphen) . dot ! exclamation mark | pipe (see also escaping pipe in tables) #特殊字符自动转义 在 HTML 文件中，有两个字符需要特殊处理： \u0026lt; 和 \u0026amp; 。 \u0026lt; 符号用于起始标签，\u0026amp; 符号则用于标记 HTML 实体，如果你只是想要使用这些符号，你必须要使用实体的形式，像是 \u0026lt; 和 \u0026amp;。\n\u0026amp; 符号其实很容易让写作网页文件的人感到困扰，如果你要打「AT\u0026amp;T」 ，你必须要写成「AT\u0026amp;T」 ，还得转换网址内的 \u0026amp; 符号，如果你要链接到：\n1 http://images.google.com/images?num=30\u0026amp;q=larry+bird 你必须要把网址转成：\n1 http://images.google.com/images?num=30\u0026amp;amp;q=larry+bird 才能放到链接标签的 href 属性里。不用说也知道这很容易忘记，这也可能是 HTML 标准检查所检查到的错误中，数量最多的。\nMarkdown 允许你直接使用这些符号，它帮你自动转义字符。如果你使用 \u0026amp; 符号的作为 HTML 实体的一部分，那么它不会被转换，而在其它情况下，它则会被转换成 \u0026amp;。所以你如果要在文件中插入一个著作权的符号，你可以这样写：\n1 \u0026amp;copy; Markdown 将不会对这段文字做修改，但是如果你这样写：\n1 AT\u0026amp;T Markdown 就会将它转为：\n1 AT\u0026amp;amp;T 类似的状况也会发生在 \u0026lt; 符号上，因为 Markdown 支持 行内 HTML ，如果你使用 \u0026lt; 符号作为 HTML 标签的分隔符，那 Markdown 也不会对它做任何转换，但是如果你是写：\n1 4 \u0026lt; 5 Markdown 将会把它转换为：\n1 4 \u0026amp;lt; 5 需要特别注意的是，在 Markdown 的块级元素和内联元素中， \u0026lt; 和 \u0026amp; 两个符号都会被自动转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML。（在 HTML 语法中，你要手动把所有的 \u0026lt; 和 \u0026amp; 都转换为 HTML 实体。）\nMarkdown 内嵌 HTML 标签 对于 Markdown 涵盖范围之外的标签，都可以直接在文件里面用 HTML 本身。如需使用 HTML，不需要额外标注这是 HTML 或是 Markdown，只需 HTML 标签添加到 Markdown 文本中即可。\n#行级內联标签 HTML 的行级內联标签如 \u0026lt;span\u0026gt;、\u0026lt;cite\u0026gt;、\u0026lt;del\u0026gt; 不受限制，可以在 Markdown 的段落、列表或是标题里任意使用。依照个人习惯，甚至可以不用 Markdown 格式，而采用 HTML 标签来格式化。例如：如果比较喜欢 HTML 的 \u0026lt;a\u0026gt; 或 \u0026lt;img\u0026gt; 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图片语法。当你需要更改元素的属性时（例如为文本指定颜色或更改图像的宽度），使用 HTML 标签更方便些。\nHTML 行级內联标签和区块标签不同，在內联标签的范围内， Markdown 的语法是可以解析的。\n1 This **word** is bold. This \u0026lt;em\u0026gt;word\u0026lt;/em\u0026gt; is italic. 渲染效果如下:\nThis word is bold. This word is italic.\n#区块标签 区块元素──比如 \u0026lt;div\u0026gt;、\u0026lt;table\u0026gt;、\u0026lt;pre\u0026gt;、\u0026lt;p\u0026gt; 等标签，必须在前后加上空行，以便于内容区分。而且这些元素的开始与结尾标签，不可以用 tab 或是空白来缩进。Markdown 会自动识别这区块元素，避免在区块标签前后加上没有必要的 \u0026lt;p\u0026gt; 标签。\n例如，在 Markdown 文件里加上一段 HTML 表格：\n1 2 3 4 5 6 7 8 9 This is a regular paragraph. \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Foo\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; This is another regular paragraph. 请注意，Markdown 语法在 HTML 区块标签中将不会被进行处理。例如，你无法在 HTML 区块内使用 Markdown 形式的*强调*。\n#HTML 用法最佳实践 出于安全原因，并非所有 Markdown 应用程序都支持在 Markdown 文档中添加 HTML。如有疑问，请查看相应 Markdown 应用程序的手册。某些应用程序只支持 HTML 标签的子集。\n对于 HTML 的块级元素 \u0026lt;div\u0026gt;、\u0026lt;table\u0026gt;、\u0026lt;pre\u0026gt; 和 \u0026lt;p\u0026gt;，请在其前后使用空行（blank lines）与其它内容进行分隔。尽量不要使用制表符（tabs）或空格（spaces）对 HTML 标签做缩进，否则将影响格式。\n在 HTML 块级标签内不能使用 Markdown 语法。例如 \u0026lt;p\u0026gt;italic and **bold**\u0026lt;/p\u0026gt; 将不起作用。\n","date":"2024-05-11T00:00:00Z","image":"https://yanbin582.github.io/p/markdown_grammar/mark_hu17144337700073756952.png","permalink":"https://yanbin582.github.io/p/markdown_grammar/","title":"Markdown_Grammar"},{"content":"求整数的因子（也称为 约数）可以使用 从 1 到 √N 迭代的方法，这样可以大幅减少计算次数，从 O(N) 优化到 O(√N)，大幅提升速度。\n1. O(√N) 高效因子枚举 原理：\n如果 x 是 N 的因子，则 N/x 也是 N 的因子，只需要遍历 1 到 √N 即可找到所有因子。 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 java复制编辑import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); // 读取整数 N sc.close(); List\u0026lt;Integer\u0026gt; factors = new ArrayList\u0026lt;\u0026gt;(); for (int i = 1; i * i \u0026lt;= n; i++) { if (n % i == 0) { factors.add(i); // i 是因子 if (i != n / i) { factors.add(n / i); // N / i 也是因子 } } } // 因子排序（如果需要从小到大排列） Collections.sort(factors); System.out.println(factors); } } 示例：\n1 2 makefile复制编辑输入: 36 输出: [1, 2, 3, 4, 6, 9, 12, 18, 36] 时间复杂度：O(√N)，相比 O(N) 的暴力方法，速度快很多！\n2. 只判断因子个数（不存储） 如果你只想知道 因子个数，可以用计数器：\n1 2 3 4 5 6 7 8 java复制编辑int count = 0; for (int i = 1; i * i \u0026lt;= n; i++) { if (n % i == 0) { count++; if (i != n / i) count++; // 计数因子 } } System.out.println(count); 示例：\n1 2 makefile复制编辑输入: 36 输出: 9 // 因子个数 3. 特殊优化：只找素因子 如果你只想找 素数因子（即 N 被哪些素数整除），可以用试除法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 java复制编辑public static List\u0026lt;Integer\u0026gt; primeFactors(int n) { List\u0026lt;Integer\u0026gt; primes = new ArrayList\u0026lt;\u0026gt;(); // 先除去 2 while (n % 2 == 0) { primes.add(2); n /= 2; } // 再检查奇数 for (int i = 3; i * i \u0026lt;= n; i += 2) { while (n % i == 0) { primes.add(i); n /= i; } } // 如果剩余的是素数 if (n \u0026gt; 1) primes.add(n); return primes; } 示例：\n1 2 less复制编辑输入: 36 输出: [2, 2, 3, 3] // 36 = 2² × 3² 时间复杂度：O(√N)，比 O(N) 方法快很多。\n总结 方法 适用场景 复杂度 备注 O(√N) 遍历因子 找出所有因子 O(√N) 推荐 O(√N) 计数因子 只求因子个数 O(√N) 无需存储 试除法找素因子 仅找素因子 O(√N) 用于分解质因数 如果只是找因子，推荐 O(√N) 方法，速度快，代码简洁！ 🚀\n例题： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 import java.util.*; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); long n = sc.nextLong(); // 读取 N，注意这里用 long，防止溢出 sc.close(); int maxLen = 0; // 记录最长长度 int start = 0; // 记录最长序列的起始因子 // 遍历起始因子 i，从 2 开始（1 不算） for (int i = 2; i * i \u0026lt;= n; i++) { long product = 1; int j = i; // 计算连续乘积，直到超出 N while (product * j \u0026lt;= n) { product *= j; // 如果这个连续乘积刚好整除 N if (n % product == 0) { int length = j - i + 1; // 计算当前序列的长度 if (length \u0026gt; maxLen) { maxLen = length; start = i; } } j++; // 继续尝试下一个连续因子 } } // 如果没有找到合适的连续因子，最长序列就是 N 本身 if (maxLen == 0) { System.out.println(1); System.out.println(n); } else { System.out.println(maxLen); for (int i = 0; i \u0026lt; maxLen; i++) { if (i \u0026gt; 0) System.out.print(\u0026#34;*\u0026#34;); System.out.print(start + i); } } } } ","date":"2024-05-11T00:00:00Z","image":"https://yanbin582.github.io/p/%E6%95%B4%E6%95%B0%E5%9B%A0%E5%AD%90%E7%9A%84%E5%BF%AB%E9%80%9F%E6%B1%82%E6%B3%95/1_hu10511767601257929355.png","permalink":"https://yanbin582.github.io/p/%E6%95%B4%E6%95%B0%E5%9B%A0%E5%AD%90%E7%9A%84%E5%BF%AB%E9%80%9F%E6%B1%82%E6%B3%95/","title":"整数因子的快速求法"}]